<?php
/**
 * ListingApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ListingApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ListingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restListingsGet
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsGet($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restListingsGetWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restListingsGetWithHttpInfo
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsGetWithHttpInfo($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsGetAsync
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsGetAsync($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        return $this->restListingsGetAsyncWithHttpInfo($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsGetAsyncWithHttpInfo
     *
     * List listing
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsGetAsyncWithHttpInfo($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsGetRequest($id, $item_id, $type_id, $stock_dependence_type_id, $unit_combination_id, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsGet'
     *
     * @param  int $id Filter that restricts the search result to listings with specific listing ID. Several IDs can be entered as array. (optional)
     * @param  int $item_id Filter that restricts the search result to listings with specific item ID. Several IDs can be entered as array. (optional)
     * @param  int $type_id Filter that restricts the search result to listings with specific type ID. Several IDs can be entered as array. (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listings with specific stock dependence type ID. Several IDs can be entered as array. (optional)
     * @param  int $unit_combination_id Filter that restricts the search result to listings with specific unit combination ID. Several IDs can be entered as array. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsGetRequest($id = null, $item_id = null, $type_id = null, $stock_dependence_type_id = null, $unit_combination_id = null, $page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemId'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }
        // query params
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = ObjectSerializer::toQueryValue($stock_dependence_type_id);
        }
        // query params
        if ($unit_combination_id !== null) {
            $queryParams['unitCombinationId'] = ObjectSerializer::toQueryValue($unit_combination_id);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdDelete
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsIdDelete($id)
    {
        list($response) = $this->restListingsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsIdDeleteWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdDeleteAsync
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdDeleteAsync($id)
    {
        return $this->restListingsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdDelete'
     *
     * @param  int $id The listing ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdGet
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingModelsListing
     */
    public function restListingsIdGet($id, $with = null)
    {
        list($response) = $this->restListingsIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsIdGetWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingModelsListing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingModelsListing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdGetAsync
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdGetAsync($id, $with = null)
    {
        return $this->restListingsIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdGetAsyncWithHttpInfo
     *
     * Get a listing
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdGet'
     *
     * @param  int $id The ID of the listing entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;stockDependenceType&#x27;, &#x27;type&#x27;, &#x27;markets&#x27;, &#x27;properties&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdGet'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsIdPut
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingModelsListing
     */
    public function restListingsIdPut($id, $body = null)
    {
        list($response) = $this->restListingsIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation restListingsIdPutWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingModelsListing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingModelsListing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsIdPutAsync
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdPutAsync($id, $body = null)
    {
        return $this->restListingsIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsIdPutAsyncWithHttpInfo
     *
     * Update a listing
     *
     * @param  int $id The ID of the listing. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsIdPut'
     *
     * @param  int $id The ID of the listing. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsIdPut'
            );
        }

        $resourcePath = '/rest/listings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDelete
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsLayoutTemplatesIdDelete($id)
    {
        list($response) = $this->restListingsLayoutTemplatesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsync
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsync($id)
    {
        return $this->restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete a layout template
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsLayoutTemplatesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdDelete'
     *
     * @param  int $id The layout template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGet
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate
     */
    public function restListingsLayoutTemplatesIdGet($id)
    {
        list($response) = $this->restListingsLayoutTemplatesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesIdGetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate';
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsync
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsync($id)
    {
        return $this->restListingsLayoutTemplatesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesIdGetAsyncWithHttpInfo
     *
     * Get a layout template
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate';
        $request = $this->restListingsLayoutTemplatesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesIdGet'
     *
     * @param  int $id The ID of the layout template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsLayoutTemplatesIdGet'
            );
        }

        $resourcePath = '/rest/listings/layout_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsLayoutTemplatesPost
     *
     * Create new layout template
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate
     */
    public function restListingsLayoutTemplatesPost($body = null)
    {
        list($response) = $this->restListingsLayoutTemplatesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsLayoutTemplatesPostWithHttpInfo
     *
     * Create new layout template
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsLayoutTemplatesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate';
        $request = $this->restListingsLayoutTemplatesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsync
     *
     * Create new layout template
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsync($body = null)
    {
        return $this->restListingsLayoutTemplatesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsLayoutTemplatesPostAsyncWithHttpInfo
     *
     * Create new layout template
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsLayoutTemplatesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingLayoutTemplateModelsLayoutTemplate';
        $request = $this->restListingsLayoutTemplatesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsLayoutTemplatesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsLayoutTemplatesPostRequest($body = null)
    {

        $resourcePath = '/rest/listings/layout_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesGet
     *
     * Get all listing market directories
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory[]
     */
    public function restListingsMarketsDirectoriesGet()
    {
        list($response) = $this->restListingsMarketsDirectoriesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesGetWithHttpInfo
     *
     * Get all listing market directories
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory[]';
        $request = $this->restListingsMarketsDirectoriesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsync
     *
     * Get all listing market directories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsync()
    {
        return $this->restListingsMarketsDirectoriesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesGetAsyncWithHttpInfo
     *
     * Get all listing market directories
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory[]';
        $request = $this->restListingsMarketsDirectoriesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesGetRequest()
    {

        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDelete
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsMarketsDirectoriesIdDelete($id)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsync
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsync($id)
    {
        return $this->restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsDirectoriesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdDelete'
     *
     * @param  int $id The listing market directory ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGet
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdGet($id)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdGetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsync
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsync($id)
    {
        return $this->restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market directory
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdGet'
     *
     * @param  int $id The ID of the listing market directory entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPut
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesIdPut($id, $body = null)
    {
        list($response) = $this->restListingsMarketsDirectoriesIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsync
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsync($id, $body = null)
    {
        return $this->restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo
     *
     * Update listing market directory
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesIdPut'
     *
     * @param  int $id The listing market directory ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsDirectoriesIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/directories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsDirectoriesPost
     *
     * Create listing market directory
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory
     */
    public function restListingsMarketsDirectoriesPost($body = null)
    {
        list($response) = $this->restListingsMarketsDirectoriesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsMarketsDirectoriesPostWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsDirectoriesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsync
     *
     * Create listing market directory
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsync($body = null)
    {
        return $this->restListingsMarketsDirectoriesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsDirectoriesPostAsyncWithHttpInfo
     *
     * Create listing market directory
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsDirectoriesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketDirectoryModelsListingMarketDirectory';
        $request = $this->restListingsMarketsDirectoriesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsDirectoriesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsDirectoriesPostRequest($body = null)
    {

        $resourcePath = '/rest/listings/markets/directories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsFindGet
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsFindGet($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        list($response) = $this->restListingsMarketsFindGetWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsFindGetWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsFindGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsFindGetAsync
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsFindGetAsync($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        return $this->restListingsMarketsFindGetAsyncWithHttpInfo($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsFindGetAsyncWithHttpInfo
     *
     * Find listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsFindGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsFindGetRequest($page, $items_per_page, $id, $variations, $referrer_id, $credentials_id, $directory_id, $item_id, $shipping_profile_id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsFindGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsFindGetRequest($page = null, $items_per_page = null, $id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $item_id = null, $shipping_profile_id = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/find';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($variations !== null) {
            $queryParams['variations'] = ObjectSerializer::toQueryValue($variations);
        }
        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }
        // query params
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = ObjectSerializer::toQueryValue($credentials_id);
        }
        // query params
        if ($directory_id !== null) {
            $queryParams['directoryId'] = ObjectSerializer::toQueryValue($directory_id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemId'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = ObjectSerializer::toQueryValue($shipping_profile_id);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsGet
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#x27;enabled&#x27;, &#x27;disabled&#x27;, &#x27;online&#x27;, &#x27;offline&#x27; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsGet($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        list($response) = $this->restListingsMarketsGetWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsGetWithHttpInfo
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#x27;enabled&#x27;, &#x27;disabled&#x27;, &#x27;online&#x27;, &#x27;offline&#x27; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsGetAsync
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#x27;enabled&#x27;, &#x27;disabled&#x27;, &#x27;online&#x27;, &#x27;offline&#x27; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsGetAsync($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        return $this->restListingsMarketsGetAsyncWithHttpInfo($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsGetAsyncWithHttpInfo
     *
     * List listing markets
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#x27;enabled&#x27;, &#x27;disabled&#x27;, &#x27;online&#x27;, &#x27;offline&#x27; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsGetRequest($page, $items_per_page, $id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status, $stock_condition, $shipping_profile_id, $updated_at_from, $updated_at_to, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing markets that match the given ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing markets that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing markets with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing markets with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing markets with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing markets with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing markets that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing markets with given duration. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing markets that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing markets that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing markets that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing markets that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $status Filter that restricts the search result to listing markets with a custom status condition. Available values are &#x27;enabled&#x27;, &#x27;disabled&#x27;, &#x27;online&#x27;, &#x27;offline&#x27; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing markets with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  int $shipping_profile_id Filter that restricts the search result to listing markets that belong to a given shipping profile ID (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsGetRequest($page = null, $items_per_page = null, $id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status = null, $stock_condition = null, $shipping_profile_id = null, $updated_at_from = null, $updated_at_to = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($variation_id !== null) {
            $queryParams['variationId'] = ObjectSerializer::toQueryValue($variation_id);
        }
        // query params
        if ($variations !== null) {
            $queryParams['variations'] = ObjectSerializer::toQueryValue($variations);
        }
        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }
        // query params
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = ObjectSerializer::toQueryValue($credentials_id);
        }
        // query params
        if ($directory_id !== null) {
            $queryParams['directoryId'] = ObjectSerializer::toQueryValue($directory_id);
        }
        // query params
        if ($verified !== null) {
            $queryParams['verified'] = ObjectSerializer::toQueryValue($verified);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($listing_id !== null) {
            $queryParams['listingId'] = ObjectSerializer::toQueryValue($listing_id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemId'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($listing_type_id !== null) {
            $queryParams['listingTypeId'] = ObjectSerializer::toQueryValue($listing_type_id);
        }
        // query params
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = ObjectSerializer::toQueryValue($stock_dependence_type_id);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status);
        }
        // query params
        if ($stock_condition !== null) {
            $queryParams['stockCondition'] = ObjectSerializer::toQueryValue($stock_condition);
        }
        // query params
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = ObjectSerializer::toQueryValue($shipping_profile_id);
        }
        // query params
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = ObjectSerializer::toQueryValue($updated_at_from);
        }
        // query params
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = ObjectSerializer::toQueryValue($updated_at_to);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesEndIdDelete
     *
     * End the listing
     *
     * @param  int $id The ID of the listing market history that needs to be ended. This must be passed as an array. This parameter is only needed if more than one listing market history should be ended. (required)
     * @param  bool $delete_on_success Tells if the listing market history should also be deleted from the database. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsMarketsHistoriesEndIdDelete($id, $delete_on_success = null)
    {
        list($response) = $this->restListingsMarketsHistoriesEndIdDeleteWithHttpInfo($id, $delete_on_success);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesEndIdDeleteWithHttpInfo
     *
     * End the listing
     *
     * @param  int $id The ID of the listing market history that needs to be ended. This must be passed as an array. This parameter is only needed if more than one listing market history should be ended. (required)
     * @param  bool $delete_on_success Tells if the listing market history should also be deleted from the database. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesEndIdDeleteWithHttpInfo($id, $delete_on_success = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesEndIdDeleteRequest($id, $delete_on_success);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesEndIdDeleteAsync
     *
     * End the listing
     *
     * @param  int $id The ID of the listing market history that needs to be ended. This must be passed as an array. This parameter is only needed if more than one listing market history should be ended. (required)
     * @param  bool $delete_on_success Tells if the listing market history should also be deleted from the database. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesEndIdDeleteAsync($id, $delete_on_success = null)
    {
        return $this->restListingsMarketsHistoriesEndIdDeleteAsyncWithHttpInfo($id, $delete_on_success)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesEndIdDeleteAsyncWithHttpInfo
     *
     * End the listing
     *
     * @param  int $id The ID of the listing market history that needs to be ended. This must be passed as an array. This parameter is only needed if more than one listing market history should be ended. (required)
     * @param  bool $delete_on_success Tells if the listing market history should also be deleted from the database. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesEndIdDeleteAsyncWithHttpInfo($id, $delete_on_success = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesEndIdDeleteRequest($id, $delete_on_success);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesEndIdDelete'
     *
     * @param  int $id The ID of the listing market history that needs to be ended. This must be passed as an array. This parameter is only needed if more than one listing market history should be ended. (required)
     * @param  bool $delete_on_success Tells if the listing market history should also be deleted from the database. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesEndIdDeleteRequest($id, $delete_on_success = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesEndIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/histories/end/{id?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delete_on_success !== null) {
            $queryParams['deleteOnSuccess'] = ObjectSerializer::toQueryValue($delete_on_success);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesGet
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsHistoriesGet($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        list($response) = $this->restListingsMarketsHistoriesGetWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesGetWithHttpInfo
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesGetWithHttpInfo($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsync
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsync($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        return $this->restListingsMarketsHistoriesGetAsyncWithHttpInfo($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesGetAsyncWithHttpInfo
     *
     * List listing market history
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsHistoriesGetRequest($page, $items_per_page, $listing_market_id, $variation_id, $variations, $referrer_id, $credentials_id, $directory_id, $verified, $duration, $external_id, $listing_id, $item_id, $listing_type_id, $stock_dependence_type_id, $status_id, $stock_condition, $updated_at_from, $updated_at_to, $text_data, $first_platform_category_id, $second_platform_category_id, $first_shop_category_id, $second_shop_category_id, $third_shop_category_id, $shipping_profile_id, $last_sale, $is_ebay_plus, $is_click_and_collect, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market histories that match the given listing market ID(s). (optional)
     * @param  int $variation_id Filter that restricts the search result to listing market histories that match the given variation ID(s). (optional)
     * @param  string $variations Filter that restricts the search result to listing market histories with a custom variation condition. Available values are &#x27;all&#x27;, &#x27;fixed&#x27;. (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing market histories with given referrer ID. (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing market histories with given credential ID. (optional)
     * @param  int $directory_id Filter that restricts the search result to listing market histories with a given directory ID. (optional)
     * @param  string $verified Filter that restricts the search result to listing market histories that are verified. Available values are &#x27;succeeded&#x27;,&#x27;unknown&#x27; or &#x27;failed&#x27;. (optional)
     * @param  string $duration Filter that restricts the search result to listing market histories with given duration. (optional)
     * @param  string $external_id Filter that restricts the search result to listing market histories with given external id. (optional)
     * @param  int $listing_id Filter that restricts the search result to listing market histories that belong to a given listing ID. (optional)
     * @param  int $item_id Filter that restricts the search result to listing market histories that belong to a given item ID. (optional)
     * @param  int $listing_type_id Filter that restricts the search result to listing market histories that belong to a listing of a custom type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Auction&lt;/li&gt;     &lt;li&gt;2 - Fixed price&lt;/li&gt;     &lt;li&gt;3 - Shop (only for Hood listings)&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $stock_dependence_type_id Filter that restricts the search result to listing market histories that belong to a listing with a custom stock dependence type ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Unlimited stock with automatic synchronisation&lt;/li&gt;     &lt;li&gt;2 - Limited and reserved stock&lt;/li&gt;     &lt;li&gt;3 - Limited and unreserved stock&lt;/li&gt;     &lt;li&gt;4 - Unlimited stock without automatich synchronisation&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  int $status_id Filter that restricts the search result to listing market histories with a custom status status ID. Available values are:     &lt;ul&gt;     &lt;li&gt;1 - Active listing market histories&lt;/li&gt;     &lt;li&gt;2 - Ended listing market histories&lt;/li&gt;     &lt;li&gt;3 - Relisted listing market histories&lt;/li&gt;     &lt;li&gt;4 - Hidden listing market histories&lt;/li&gt;     &lt;/ul&gt; (optional)
     * @param  string $stock_condition Filter that restricts the search result to listing market histories with a custom stock condition. Available values are &#x27;stockNetLessEqualZero&#x27;, &#x27;stockNetLessZero&#x27;, &#x27;stockNetGreaterZero&#x27;, &#x27;stockGrossLessEqualZero&#x27;, &#x27;stockGrossLessZero&#x27;, &#x27;stockGrossGreaterZero&#x27;, &#x27;stockNetTotalLessEqualZero&#x27;, &#x27;stockNetTotalLessZero&#x27;, &#x27;stockNetTotalGreaterZero&#x27; (optional)
     * @param  string $updated_at_from Filter that restricts the search result to listing market histories that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $updated_at_to Filter that restricts the search result to listing market histories that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $text_data Filter that restricts the search result to listing market histories that match given text in listing title or description. (optional)
     * @param  string $first_platform_category_id Filter that restricts the search result to listing market histories with first platform category ID equal to the given ID. (optional)
     * @param  string $second_platform_category_id Filter that restricts the search result to listing market histories with second platform category ID equal to the given ID. (optional)
     * @param  string $first_shop_category_id Filter that restricts the search result to listing market histories with first shop category ID equal to the given ID. (optional)
     * @param  string $second_shop_category_id Filter that restricts the search result to listing market histories with second shop category ID equal to the given ID. (optional)
     * @param  string $third_shop_category_id Filter that restricts the search result to listing market histories with third shop category ID equal to the given ID. (optional)
     * @param  string $shipping_profile_id Filter that restricts the search result to listing market histories that belong to a given shipping profile. (optional)
     * @param  string $last_sale Filter that restricts the search result to listing market histories with last sale before given date.The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $is_ebay_plus Filter that restricts the search result to listing market histories that belong to eBay Plus. (optional)
     * @param  string $is_click_and_collect Filter that restricts the search result to listing market histories that belong to eBay Click &amp; Collect. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesGetRequest($page = null, $items_per_page = null, $listing_market_id = null, $variation_id = null, $variations = null, $referrer_id = null, $credentials_id = null, $directory_id = null, $verified = null, $duration = null, $external_id = null, $listing_id = null, $item_id = null, $listing_type_id = null, $stock_dependence_type_id = null, $status_id = null, $stock_condition = null, $updated_at_from = null, $updated_at_to = null, $text_data = null, $first_platform_category_id = null, $second_platform_category_id = null, $first_shop_category_id = null, $second_shop_category_id = null, $third_shop_category_id = null, $shipping_profile_id = null, $last_sale = null, $is_ebay_plus = null, $is_click_and_collect = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/histories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = ObjectSerializer::toQueryValue($listing_market_id);
        }
        // query params
        if ($variation_id !== null) {
            $queryParams['variationId'] = ObjectSerializer::toQueryValue($variation_id);
        }
        // query params
        if ($variations !== null) {
            $queryParams['variations'] = ObjectSerializer::toQueryValue($variations);
        }
        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }
        // query params
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = ObjectSerializer::toQueryValue($credentials_id);
        }
        // query params
        if ($directory_id !== null) {
            $queryParams['directoryId'] = ObjectSerializer::toQueryValue($directory_id);
        }
        // query params
        if ($verified !== null) {
            $queryParams['verified'] = ObjectSerializer::toQueryValue($verified);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($external_id !== null) {
            $queryParams['externalId'] = ObjectSerializer::toQueryValue($external_id);
        }
        // query params
        if ($listing_id !== null) {
            $queryParams['listingId'] = ObjectSerializer::toQueryValue($listing_id);
        }
        // query params
        if ($item_id !== null) {
            $queryParams['itemId'] = ObjectSerializer::toQueryValue($item_id);
        }
        // query params
        if ($listing_type_id !== null) {
            $queryParams['listingTypeId'] = ObjectSerializer::toQueryValue($listing_type_id);
        }
        // query params
        if ($stock_dependence_type_id !== null) {
            $queryParams['stockDependenceTypeId'] = ObjectSerializer::toQueryValue($stock_dependence_type_id);
        }
        // query params
        if ($status_id !== null) {
            $queryParams['statusId'] = ObjectSerializer::toQueryValue($status_id);
        }
        // query params
        if ($stock_condition !== null) {
            $queryParams['stockCondition'] = ObjectSerializer::toQueryValue($stock_condition);
        }
        // query params
        if ($updated_at_from !== null) {
            $queryParams['updatedAtFrom'] = ObjectSerializer::toQueryValue($updated_at_from);
        }
        // query params
        if ($updated_at_to !== null) {
            $queryParams['updatedAtTo'] = ObjectSerializer::toQueryValue($updated_at_to);
        }
        // query params
        if ($text_data !== null) {
            $queryParams['textData'] = ObjectSerializer::toQueryValue($text_data);
        }
        // query params
        if ($first_platform_category_id !== null) {
            $queryParams['firstPlatformCategoryId'] = ObjectSerializer::toQueryValue($first_platform_category_id);
        }
        // query params
        if ($second_platform_category_id !== null) {
            $queryParams['secondPlatformCategoryId'] = ObjectSerializer::toQueryValue($second_platform_category_id);
        }
        // query params
        if ($first_shop_category_id !== null) {
            $queryParams['firstShopCategoryId'] = ObjectSerializer::toQueryValue($first_shop_category_id);
        }
        // query params
        if ($second_shop_category_id !== null) {
            $queryParams['secondShopCategoryId'] = ObjectSerializer::toQueryValue($second_shop_category_id);
        }
        // query params
        if ($third_shop_category_id !== null) {
            $queryParams['thirdShopCategoryId'] = ObjectSerializer::toQueryValue($third_shop_category_id);
        }
        // query params
        if ($shipping_profile_id !== null) {
            $queryParams['shippingProfileId'] = ObjectSerializer::toQueryValue($shipping_profile_id);
        }
        // query params
        if ($last_sale !== null) {
            $queryParams['lastSale'] = ObjectSerializer::toQueryValue($last_sale);
        }
        // query params
        if ($is_ebay_plus !== null) {
            $queryParams['isEbayPlus'] = ObjectSerializer::toQueryValue($is_ebay_plus);
        }
        // query params
        if ($is_click_and_collect !== null) {
            $queryParams['isClickAndCollect'] = ObjectSerializer::toQueryValue($is_click_and_collect);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGet
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;dates&#x27;, &#x27;variations&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketHistoryModelsListingMarketHistory
     */
    public function restListingsMarketsHistoriesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsMarketsHistoriesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;dates&#x27;, &#x27;variations&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketHistoryModelsListingMarketHistory, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketHistoryModelsListingMarketHistory';
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketHistoryModelsListingMarketHistory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsync
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;dates&#x27;, &#x27;variations&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsync($id, $with = null)
    {
        return $this->restListingsMarketsHistoriesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesIdGetAsyncWithHttpInfo
     *
     * Get a listing market history
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;dates&#x27;, &#x27;variations&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketHistoryModelsListingMarketHistory';
        $request = $this->restListingsMarketsHistoriesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesIdGet'
     *
     * @param  int $id The ID of the listing market history entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listingMarket&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;dates&#x27;, &#x27;variations&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/histories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesRelistIdPost
     *
     * Relist the listing
     *
     * @param  int $id The ID of the listing market history that needs to be relisted. This must be passed as an array. This parameter is only needed if more than one listing market history should be relisted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsMarketsHistoriesRelistIdPost($id)
    {
        list($response) = $this->restListingsMarketsHistoriesRelistIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesRelistIdPostWithHttpInfo
     *
     * Relist the listing
     *
     * @param  int $id The ID of the listing market history that needs to be relisted. This must be passed as an array. This parameter is only needed if more than one listing market history should be relisted. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesRelistIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesRelistIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesRelistIdPostAsync
     *
     * Relist the listing
     *
     * @param  int $id The ID of the listing market history that needs to be relisted. This must be passed as an array. This parameter is only needed if more than one listing market history should be relisted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesRelistIdPostAsync($id)
    {
        return $this->restListingsMarketsHistoriesRelistIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesRelistIdPostAsyncWithHttpInfo
     *
     * Relist the listing
     *
     * @param  int $id The ID of the listing market history that needs to be relisted. This must be passed as an array. This parameter is only needed if more than one listing market history should be relisted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesRelistIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesRelistIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesRelistIdPost'
     *
     * @param  int $id The ID of the listing market history that needs to be relisted. This must be passed as an array. This parameter is only needed if more than one listing market history should be relisted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesRelistIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesRelistIdPost'
            );
        }

        $resourcePath = '/rest/listings/markets/histories/relist/{id?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsHistoriesUpdateIdPut
     *
     * Update listing market histories
     *
     * @param  int $id The ID of the listing market history that needs to be updated. This must be passed as an array. This parameter is only needed if more than one listing market history should be updated. (required)
     * @param  int $options Multiple update options. Available values are:     &lt;ul&gt;     &lt;li&gt;all - Updates everything     &lt;li&gt;title - Updates the title     &lt;li&gt;subtitle - Updates the subtitle&lt;/li&gt;&lt;/li&gt;     &lt;li&gt;itemSpecifics - Updates the item specifics&lt;/li&gt;     &lt;li&gt;category - Updates the platform and shop category&lt;/li&gt;     &lt;li&gt;listingDetails - Updates listing details&lt;/li&gt;     &lt;li&gt;enhancements - Updates the enhancements information&lt;/li&gt;     &lt;li&gt;duration - Updates the duration&lt;/li&gt;     &lt;li&gt;shipping - Updates the shipping information&lt;/li&gt;     &lt;li&gt;description - Updates the description&lt;/li&gt;     &lt;li&gt;pictures - Updates the entry pictures&lt;/li&gt;     &lt;li&gt;quantityAndPrice - Updates the quantity and price (also for variations)&lt;/li&gt;     &lt;li&gt;resetVariations - Reset the variations. The variations from the item are transmitted again&lt;/li&gt;     &lt;li&gt;partsFitmentList - Updates the parts fitment information (only available for eBay)&lt;/li&gt;     &lt;li&gt;loyaltyProgram - Updates the listing loyalty program information (only available for eBay Plus)&lt;/li&gt;     &lt;li&gt;resetRrp - Reset the recommended retail price information (only available for eBay)&lt;/li&gt;     &lt;li&gt;payment - Updates payment information (only available for Hood)&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsMarketsHistoriesUpdateIdPut($id, $options = null)
    {
        list($response) = $this->restListingsMarketsHistoriesUpdateIdPutWithHttpInfo($id, $options);
        return $response;
    }

    /**
     * Operation restListingsMarketsHistoriesUpdateIdPutWithHttpInfo
     *
     * Update listing market histories
     *
     * @param  int $id The ID of the listing market history that needs to be updated. This must be passed as an array. This parameter is only needed if more than one listing market history should be updated. (required)
     * @param  int $options Multiple update options. Available values are:     &lt;ul&gt;     &lt;li&gt;all - Updates everything     &lt;li&gt;title - Updates the title     &lt;li&gt;subtitle - Updates the subtitle&lt;/li&gt;&lt;/li&gt;     &lt;li&gt;itemSpecifics - Updates the item specifics&lt;/li&gt;     &lt;li&gt;category - Updates the platform and shop category&lt;/li&gt;     &lt;li&gt;listingDetails - Updates listing details&lt;/li&gt;     &lt;li&gt;enhancements - Updates the enhancements information&lt;/li&gt;     &lt;li&gt;duration - Updates the duration&lt;/li&gt;     &lt;li&gt;shipping - Updates the shipping information&lt;/li&gt;     &lt;li&gt;description - Updates the description&lt;/li&gt;     &lt;li&gt;pictures - Updates the entry pictures&lt;/li&gt;     &lt;li&gt;quantityAndPrice - Updates the quantity and price (also for variations)&lt;/li&gt;     &lt;li&gt;resetVariations - Reset the variations. The variations from the item are transmitted again&lt;/li&gt;     &lt;li&gt;partsFitmentList - Updates the parts fitment information (only available for eBay)&lt;/li&gt;     &lt;li&gt;loyaltyProgram - Updates the listing loyalty program information (only available for eBay Plus)&lt;/li&gt;     &lt;li&gt;resetRrp - Reset the recommended retail price information (only available for eBay)&lt;/li&gt;     &lt;li&gt;payment - Updates payment information (only available for Hood)&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsHistoriesUpdateIdPutWithHttpInfo($id, $options = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesUpdateIdPutRequest($id, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsHistoriesUpdateIdPutAsync
     *
     * Update listing market histories
     *
     * @param  int $id The ID of the listing market history that needs to be updated. This must be passed as an array. This parameter is only needed if more than one listing market history should be updated. (required)
     * @param  int $options Multiple update options. Available values are:     &lt;ul&gt;     &lt;li&gt;all - Updates everything     &lt;li&gt;title - Updates the title     &lt;li&gt;subtitle - Updates the subtitle&lt;/li&gt;&lt;/li&gt;     &lt;li&gt;itemSpecifics - Updates the item specifics&lt;/li&gt;     &lt;li&gt;category - Updates the platform and shop category&lt;/li&gt;     &lt;li&gt;listingDetails - Updates listing details&lt;/li&gt;     &lt;li&gt;enhancements - Updates the enhancements information&lt;/li&gt;     &lt;li&gt;duration - Updates the duration&lt;/li&gt;     &lt;li&gt;shipping - Updates the shipping information&lt;/li&gt;     &lt;li&gt;description - Updates the description&lt;/li&gt;     &lt;li&gt;pictures - Updates the entry pictures&lt;/li&gt;     &lt;li&gt;quantityAndPrice - Updates the quantity and price (also for variations)&lt;/li&gt;     &lt;li&gt;resetVariations - Reset the variations. The variations from the item are transmitted again&lt;/li&gt;     &lt;li&gt;partsFitmentList - Updates the parts fitment information (only available for eBay)&lt;/li&gt;     &lt;li&gt;loyaltyProgram - Updates the listing loyalty program information (only available for eBay Plus)&lt;/li&gt;     &lt;li&gt;resetRrp - Reset the recommended retail price information (only available for eBay)&lt;/li&gt;     &lt;li&gt;payment - Updates payment information (only available for Hood)&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesUpdateIdPutAsync($id, $options = null)
    {
        return $this->restListingsMarketsHistoriesUpdateIdPutAsyncWithHttpInfo($id, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsHistoriesUpdateIdPutAsyncWithHttpInfo
     *
     * Update listing market histories
     *
     * @param  int $id The ID of the listing market history that needs to be updated. This must be passed as an array. This parameter is only needed if more than one listing market history should be updated. (required)
     * @param  int $options Multiple update options. Available values are:     &lt;ul&gt;     &lt;li&gt;all - Updates everything     &lt;li&gt;title - Updates the title     &lt;li&gt;subtitle - Updates the subtitle&lt;/li&gt;&lt;/li&gt;     &lt;li&gt;itemSpecifics - Updates the item specifics&lt;/li&gt;     &lt;li&gt;category - Updates the platform and shop category&lt;/li&gt;     &lt;li&gt;listingDetails - Updates listing details&lt;/li&gt;     &lt;li&gt;enhancements - Updates the enhancements information&lt;/li&gt;     &lt;li&gt;duration - Updates the duration&lt;/li&gt;     &lt;li&gt;shipping - Updates the shipping information&lt;/li&gt;     &lt;li&gt;description - Updates the description&lt;/li&gt;     &lt;li&gt;pictures - Updates the entry pictures&lt;/li&gt;     &lt;li&gt;quantityAndPrice - Updates the quantity and price (also for variations)&lt;/li&gt;     &lt;li&gt;resetVariations - Reset the variations. The variations from the item are transmitted again&lt;/li&gt;     &lt;li&gt;partsFitmentList - Updates the parts fitment information (only available for eBay)&lt;/li&gt;     &lt;li&gt;loyaltyProgram - Updates the listing loyalty program information (only available for eBay Plus)&lt;/li&gt;     &lt;li&gt;resetRrp - Reset the recommended retail price information (only available for eBay)&lt;/li&gt;     &lt;li&gt;payment - Updates payment information (only available for Hood)&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsHistoriesUpdateIdPutAsyncWithHttpInfo($id, $options = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsHistoriesUpdateIdPutRequest($id, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsHistoriesUpdateIdPut'
     *
     * @param  int $id The ID of the listing market history that needs to be updated. This must be passed as an array. This parameter is only needed if more than one listing market history should be updated. (required)
     * @param  int $options Multiple update options. Available values are:     &lt;ul&gt;     &lt;li&gt;all - Updates everything     &lt;li&gt;title - Updates the title     &lt;li&gt;subtitle - Updates the subtitle&lt;/li&gt;&lt;/li&gt;     &lt;li&gt;itemSpecifics - Updates the item specifics&lt;/li&gt;     &lt;li&gt;category - Updates the platform and shop category&lt;/li&gt;     &lt;li&gt;listingDetails - Updates listing details&lt;/li&gt;     &lt;li&gt;enhancements - Updates the enhancements information&lt;/li&gt;     &lt;li&gt;duration - Updates the duration&lt;/li&gt;     &lt;li&gt;shipping - Updates the shipping information&lt;/li&gt;     &lt;li&gt;description - Updates the description&lt;/li&gt;     &lt;li&gt;pictures - Updates the entry pictures&lt;/li&gt;     &lt;li&gt;quantityAndPrice - Updates the quantity and price (also for variations)&lt;/li&gt;     &lt;li&gt;resetVariations - Reset the variations. The variations from the item are transmitted again&lt;/li&gt;     &lt;li&gt;partsFitmentList - Updates the parts fitment information (only available for eBay)&lt;/li&gt;     &lt;li&gt;loyaltyProgram - Updates the listing loyalty program information (only available for eBay Plus)&lt;/li&gt;     &lt;li&gt;resetRrp - Reset the recommended retail price information (only available for eBay)&lt;/li&gt;     &lt;li&gt;payment - Updates payment information (only available for Hood)&lt;/li&gt;     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsHistoriesUpdateIdPutRequest($id, $options = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsHistoriesUpdateIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/histories/update/{id?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdDelete
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsMarketsIdDelete($id)
    {
        list($response) = $this->restListingsMarketsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdDeleteWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdDeleteAsync
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsync($id)
    {
        return $this->restListingsMarketsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdDeleteAsyncWithHttpInfo
     *
     * Delete listing market
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdDelete'
     *
     * @param  int $id The listing market ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdGet
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;itemSpecifics&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket
     */
    public function restListingsMarketsIdGet($id, $with = null)
    {
        list($response) = $this->restListingsMarketsIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdGetWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;itemSpecifics&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket';
        $request = $this->restListingsMarketsIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdGetAsync
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;itemSpecifics&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdGetAsync($id, $with = null)
    {
        return $this->restListingsMarketsIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdGetAsyncWithHttpInfo
     *
     * Get a listing market
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;itemSpecifics&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket';
        $request = $this->restListingsMarketsIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdGet'
     *
     * @param  int $id The ID of the listing market entry. (required)
     * @param  int $with An array with child instances to be loaded. One of &#x27;listing&#x27;, &#x27;texts&#x27;, &#x27;properties&#x27;, &#x27;itemSpecifics&#x27;, &#x27;prices&#x27;, &#x27;dates&#x27;, &#x27;infos&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsIdPut
     *
     * Update a listing market
     *
     * @param  int $referrer_id The referrer ID. (required)
     * @param  int $id The listing market ID. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket
     */
    public function restListingsMarketsIdPut($referrer_id, $id, $body = null)
    {
        list($response) = $this->restListingsMarketsIdPutWithHttpInfo($referrer_id, $id, $body);
        return $response;
    }

    /**
     * Operation restListingsMarketsIdPutWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $referrer_id The referrer ID. (required)
     * @param  int $id The listing market ID. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsIdPutWithHttpInfo($referrer_id, $id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket';
        $request = $this->restListingsMarketsIdPutRequest($referrer_id, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsIdPutAsync
     *
     * Update a listing market
     *
     * @param  int $referrer_id The referrer ID. (required)
     * @param  int $id The listing market ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdPutAsync($referrer_id, $id, $body = null)
    {
        return $this->restListingsMarketsIdPutAsyncWithHttpInfo($referrer_id, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsIdPutAsyncWithHttpInfo
     *
     * Update a listing market
     *
     * @param  int $referrer_id The referrer ID. (required)
     * @param  int $id The listing market ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsIdPutAsyncWithHttpInfo($referrer_id, $id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket';
        $request = $this->restListingsMarketsIdPutRequest($referrer_id, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsIdPut'
     *
     * @param  int $referrer_id The referrer ID. (required)
     * @param  int $id The listing market ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsIdPutRequest($referrer_id, $id, $body = null)
    {
        // verify the required parameter 'referrer_id' is set
        if ($referrer_id === null || (is_array($referrer_id) && count($referrer_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $referrer_id when calling restListingsMarketsIdPut'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsInfosGet
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;info&#x27;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsInfosGet($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        list($response) = $this->restListingsMarketsInfosGetWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);
        return $response;
    }

    /**
     * Operation restListingsMarketsInfosGetWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;info&#x27;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsInfosGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsInfosGetAsync
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;info&#x27;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsInfosGetAsync($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        return $this->restListingsMarketsInfosGetAsyncWithHttpInfo($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsInfosGetAsyncWithHttpInfo
     *
     * Search listing market info
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;info&#x27;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsInfosGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsInfosGetRequest($page, $items_per_page, $id, $listing_market_id, $type, $code, $created_at_from, $created_at_to, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsInfosGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing market info that match the given ID(s). (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market info that match the given listing market ID(s). (optional)
     * @param  string $type Filter that restricts the search result to listing market info with a custom type. Available values are &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;info&#x27;. (optional)
     * @param  int $code Filter that restricts the search result to listing market info with given codes. (optional)
     * @param  string $created_at_from Filter that restricts the search result to listing markets that were last updated on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to listing markets that were last updated within a specified period of time. This filter can be used alone or can be combined with the UpdatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsInfosGetRequest($page = null, $items_per_page = null, $id = null, $listing_market_id = null, $type = null, $code = null, $created_at_from = null, $created_at_to = null, $with = null)
    {

        $resourcePath = '/rest/listings/markets/infos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = ObjectSerializer::toQueryValue($listing_market_id);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = ObjectSerializer::toQueryValue($created_at_from);
        }
        // query params
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = ObjectSerializer::toQueryValue($created_at_to);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGet
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsGet($body = null)
    {
        list($response) = $this->restListingsMarketsItemSpecificsGetWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsGetWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsGetRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsync
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsync($body = null)
    {
        return $this->restListingsMarketsItemSpecificsGetAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsGetAsyncWithHttpInfo
     *
     * Gets all ListingMarketItemSpecifics.
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsGetAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsGetRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsGet'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsGetRequest($body = null)
    {

        $resourcePath = '/rest/listings/markets/item_specifics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDelete
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restListingsMarketsItemSpecificsIdDelete($id)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsync
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsync($id)
    {
        return $this->restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo
     *
     * Deletes a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restListingsMarketsItemSpecificsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdDelete'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGet
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdGet($id)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdGetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsync
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsync($id)
    {
        return $this->restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo
     *
     * Gets a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPut
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific
     */
    public function restListingsMarketsItemSpecificsIdPut($id, $body = null)
    {
        list($response) = $this->restListingsMarketsItemSpecificsIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsItemSpecificsIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsync
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsync($id, $body = null)
    {
        return $this->restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo
     *
     * Updates a ListingMarketItemSpecific.
     *
     * @param  int $id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsItemSpecificsIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketItemSpecificModelsListingMarketItemSpecific';
        $request = $this->restListingsMarketsItemSpecificsIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsItemSpecificsIdPut'
     *
     * @param  int $id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsItemSpecificsIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsItemSpecificsIdPut'
            );
        }

        $resourcePath = '/rest/listings/markets/item_specifics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsPost
     *
     * Create new listing market
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket[]
     */
    public function restListingsMarketsPost($body = null)
    {
        list($response) = $this->restListingsMarketsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsMarketsPostWithHttpInfo
     *
     * Create new listing market
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket[]';
        $request = $this->restListingsMarketsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsPostAsync
     *
     * Create new listing market
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsPostAsync($body = null)
    {
        return $this->restListingsMarketsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsPostAsyncWithHttpInfo
     *
     * Create new listing market
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketModelsListingMarket[]';
        $request = $this->restListingsMarketsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsPostRequest($body = null)
    {

        $resourcePath = '/rest/listings/markets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsStartIdPost
     *
     * Start the market listing on the designated market.
     *
     * @param  int $id The ID of the listing market that needs to be started. This can also be passed as an array. (required)
     * @param  string $start_at When should the listings be started. The date has to be in the format, e.g. &#x27;2019-04-04 12:40:00&#x27;. (optional)
     * @param  int $distribution The number of minutes that the listing should be started. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsMarketsStartIdPost($id, $start_at = null, $distribution = null)
    {
        list($response) = $this->restListingsMarketsStartIdPostWithHttpInfo($id, $start_at, $distribution);
        return $response;
    }

    /**
     * Operation restListingsMarketsStartIdPostWithHttpInfo
     *
     * Start the market listing on the designated market.
     *
     * @param  int $id The ID of the listing market that needs to be started. This can also be passed as an array. (required)
     * @param  string $start_at When should the listings be started. The date has to be in the format, e.g. &#x27;2019-04-04 12:40:00&#x27;. (optional)
     * @param  int $distribution The number of minutes that the listing should be started. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsStartIdPostWithHttpInfo($id, $start_at = null, $distribution = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsStartIdPostRequest($id, $start_at, $distribution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsStartIdPostAsync
     *
     * Start the market listing on the designated market.
     *
     * @param  int $id The ID of the listing market that needs to be started. This can also be passed as an array. (required)
     * @param  string $start_at When should the listings be started. The date has to be in the format, e.g. &#x27;2019-04-04 12:40:00&#x27;. (optional)
     * @param  int $distribution The number of minutes that the listing should be started. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsStartIdPostAsync($id, $start_at = null, $distribution = null)
    {
        return $this->restListingsMarketsStartIdPostAsyncWithHttpInfo($id, $start_at, $distribution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsStartIdPostAsyncWithHttpInfo
     *
     * Start the market listing on the designated market.
     *
     * @param  int $id The ID of the listing market that needs to be started. This can also be passed as an array. (required)
     * @param  string $start_at When should the listings be started. The date has to be in the format, e.g. &#x27;2019-04-04 12:40:00&#x27;. (optional)
     * @param  int $distribution The number of minutes that the listing should be started. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsStartIdPostAsyncWithHttpInfo($id, $start_at = null, $distribution = null)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsStartIdPostRequest($id, $start_at, $distribution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsStartIdPost'
     *
     * @param  int $id The ID of the listing market that needs to be started. This can also be passed as an array. (required)
     * @param  string $start_at When should the listings be started. The date has to be in the format, e.g. &#x27;2019-04-04 12:40:00&#x27;. (optional)
     * @param  int $distribution The number of minutes that the listing should be started. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsStartIdPostRequest($id, $start_at = null, $distribution = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsStartIdPost'
            );
        }

        $resourcePath = '/rest/listings/markets/start/{id?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_at !== null) {
            $queryParams['startAt'] = ObjectSerializer::toQueryValue($start_at);
        }
        // query params
        if ($distribution !== null) {
            $queryParams['distribution'] = ObjectSerializer::toQueryValue($distribution);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsGet
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsMarketsTextsGet($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restListingsMarketsTextsGetWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsGetWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsGetWithHttpInfo($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsGetAsync
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsGetAsync($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        return $this->restListingsMarketsTextsGetAsyncWithHttpInfo($id, $listing_market_id, $language, $contains, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsGetAsyncWithHttpInfo
     *
     * List listing market texts
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsGetAsyncWithHttpInfo($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restListingsMarketsTextsGetRequest($id, $listing_market_id, $language, $contains, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsGet'
     *
     * @param  int $id Filter that restricts the search result to listing market texts with specific ID. Several IDs can be entered as array. (optional)
     * @param  int $listing_market_id Filter that restricts the search result to listing market texts with specific listing market IDs. Several IDs can be entered as array. (optional)
     * @param  string $language Filter that restricts the search result to listing market texts for a specific language. @see listing market text model language for the complete available list of language types. (optional)
     * @param  string $contains Filter that restricts the search result to listing market texts which title, subtitle or description contain the given value. (optional)
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsGetRequest($id = null, $listing_market_id = null, $language = null, $contains = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = ObjectSerializer::toQueryValue($listing_market_id);
        }
        // query params
        if ($language !== null) {
            $queryParams['language'] = ObjectSerializer::toQueryValue($language);
        }
        // query params
        if ($contains !== null) {
            $queryParams['contains'] = ObjectSerializer::toQueryValue($contains);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdDelete
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsMarketsTextsIdDelete($lang, $listing_market_id, $id)
    {
        list($response) = $this->restListingsMarketsTextsIdDeleteWithHttpInfo($lang, $listing_market_id, $id);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdDeleteWithHttpInfo($lang, $listing_market_id, $id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsync
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsync($lang, $listing_market_id, $id)
    {
        return $this->restListingsMarketsTextsIdDeleteAsyncWithHttpInfo($lang, $listing_market_id, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdDeleteAsyncWithHttpInfo
     *
     * Delete a listing market text
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdDeleteAsyncWithHttpInfo($lang, $listing_market_id, $id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdDelete'
     *
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsIdDeleteRequest($lang, $listing_market_id, $id)
    {
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsIdDelete'
            );
        }
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsIdDelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdDelete'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = ObjectSerializer::toQueryValue($listing_market_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsIdGet
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText
     */
    public function restListingsMarketsTextsIdGet($id)
    {
        list($response) = $this->restListingsMarketsTextsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsIdGetWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsIdGetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsync
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsync($id)
    {
        return $this->restListingsMarketsTextsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsIdGetAsyncWithHttpInfo
     *
     * Get a listing market text
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsIdGet'
     *
     * @param  int $id The ID of the listing market text entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsTextsIdGet'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPut
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText
     */
    public function restListingsMarketsTextsListingMarketIdLangPut($listing_market_id, $lang, $body = null)
    {
        list($response) = $this->restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo($listing_market_id, $lang, $body);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsListingMarketIdLangPutWithHttpInfo($listing_market_id, $lang, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsync
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsync($listing_market_id, $lang, $body = null)
    {
        return $this->restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo($listing_market_id, $lang, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo
     *
     * Update a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsListingMarketIdLangPutAsyncWithHttpInfo($listing_market_id, $lang, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsListingMarketIdLangPut'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  string $lang The listing market text language that should be updated. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsListingMarketIdLangPutRequest($listing_market_id, $lang, $body = null)
    {
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restListingsMarketsTextsListingMarketIdLangPut'
            );
        }

        $resourcePath = '/rest/listings/markets/texts/{listingMarketId}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($listing_market_id !== null) {
            $resourcePath = str_replace(
                '{' . 'listingMarketId' . '}',
                ObjectSerializer::toPathValue($listing_market_id),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsTextsPost
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText
     */
    public function restListingsMarketsTextsPost($listing_market_id, $body = null)
    {
        list($response) = $this->restListingsMarketsTextsPostWithHttpInfo($listing_market_id, $body);
        return $response;
    }

    /**
     * Operation restListingsMarketsTextsPostWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsTextsPostWithHttpInfo($listing_market_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsTextsPostAsync
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsPostAsync($listing_market_id, $body = null)
    {
        return $this->restListingsMarketsTextsPostAsyncWithHttpInfo($listing_market_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsTextsPostAsyncWithHttpInfo
     *
     * Create a listing market text
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsTextsPostAsyncWithHttpInfo($listing_market_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingMarketTextModelsListingMarketText';
        $request = $this->restListingsMarketsTextsPostRequest($listing_market_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsTextsPost'
     *
     * @param  int $listing_market_id The listing market ID this text belongs to. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsTextsPostRequest($listing_market_id, $body = null)
    {
        // verify the required parameter 'listing_market_id' is set
        if ($listing_market_id === null || (is_array($listing_market_id) && count($listing_market_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $listing_market_id when calling restListingsMarketsTextsPost'
            );
        }

        $resourcePath = '/rest/listings/markets/texts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($listing_market_id !== null) {
            $queryParams['listingMarketId'] = ObjectSerializer::toQueryValue($listing_market_id);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsMarketsVerifyIdPost
     *
     * Verify listing markets
     *
     * @param  int $id The ID of the listing market that need to be verified. This can also be passed as an array. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsMarketsVerifyIdPost($id)
    {
        list($response) = $this->restListingsMarketsVerifyIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsMarketsVerifyIdPostWithHttpInfo
     *
     * Verify listing markets
     *
     * @param  int $id The ID of the listing market that need to be verified. This can also be passed as an array. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsMarketsVerifyIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsVerifyIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsMarketsVerifyIdPostAsync
     *
     * Verify listing markets
     *
     * @param  int $id The ID of the listing market that need to be verified. This can also be passed as an array. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsVerifyIdPostAsync($id)
    {
        return $this->restListingsMarketsVerifyIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsMarketsVerifyIdPostAsyncWithHttpInfo
     *
     * Verify listing markets
     *
     * @param  int $id The ID of the listing market that need to be verified. This can also be passed as an array. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsMarketsVerifyIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsMarketsVerifyIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsMarketsVerifyIdPost'
     *
     * @param  int $id The ID of the listing market that need to be verified. This can also be passed as an array. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsMarketsVerifyIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsMarketsVerifyIdPost'
            );
        }

        $resourcePath = '/rest/listings/markets/verify/{id?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdDelete
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restListingsOptionTemplatesIdDelete($id)
    {
        list($response) = $this->restListingsOptionTemplatesIdDeleteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdDeleteWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsync
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsync($id)
    {
        return $this->restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo
     *
     * Delete option template
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restListingsOptionTemplatesIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdDelete'
     *
     * @param  int $id The option template ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdDelete'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdGet
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate
     */
    public function restListingsOptionTemplatesIdGet($id)
    {
        list($response) = $this->restListingsOptionTemplatesIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdGetWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdGetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsync
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsync($id)
    {
        return $this->restListingsOptionTemplatesIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdGetAsyncWithHttpInfo
     *
     * Get option template
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdGet'
     *
     * @param  int $id The ID of the option template entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdGet'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesIdPut
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate
     */
    public function restListingsOptionTemplatesIdPut($id, $body = null)
    {
        list($response) = $this->restListingsOptionTemplatesIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesIdPutWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsync
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsync($id, $body = null)
    {
        return $this->restListingsOptionTemplatesIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesIdPutAsyncWithHttpInfo
     *
     * Update option template
     *
     * @param  int $id The option template ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesIdPut'
     *
     * @param  int $id The option template ID. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsOptionTemplatesIdPut'
            );
        }

        $resourcePath = '/rest/listings/option_templates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPost
     *
     * Create option template
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate
     */
    public function restListingsOptionTemplatesPost($body = null)
    {
        list($response) = $this->restListingsOptionTemplatesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPostWithHttpInfo
     *
     * Create option template
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPostAsync
     *
     * Create option template
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsync($body = null)
    {
        return $this->restListingsOptionTemplatesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPostAsyncWithHttpInfo
     *
     * Create option template
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingOptionTemplateModelsOptionTemplate';
        $request = $this->restListingsOptionTemplatesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesPostRequest($body = null)
    {

        $resourcePath = '/rest/listings/option_templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGet
     *
     * Get a preview list of option templates
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restListingsOptionTemplatesPreviewGet()
    {
        list($response) = $this->restListingsOptionTemplatesPreviewGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetWithHttpInfo
     *
     * Get a preview list of option templates
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsOptionTemplatesPreviewGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsOptionTemplatesPreviewGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsync
     *
     * Get a preview list of option templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsync()
    {
        return $this->restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo
     *
     * Get a preview list of option templates
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsOptionTemplatesPreviewGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restListingsOptionTemplatesPreviewGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsOptionTemplatesPreviewGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsOptionTemplatesPreviewGetRequest()
    {

        $resourcePath = '/rest/listings/option_templates/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsPost
     *
     * Create new listing
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingModelsListing
     */
    public function restListingsPost($body = null)
    {
        list($response) = $this->restListingsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restListingsPostWithHttpInfo
     *
     * Create new listing
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingModelsListing, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingModelsListing',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsPostAsync
     *
     * Create new listing
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsPostAsync($body = null)
    {
        return $this->restListingsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsPostAsyncWithHttpInfo
     *
     * Create new listing
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingModelsListing';
        $request = $this->restListingsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsPostRequest($body = null)
    {

        $resourcePath = '/rest/listings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesGet
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsShippingProfilesGet($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        list($response) = $this->restListingsShippingProfilesGetWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesGetWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesGetWithHttpInfo($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        $returnType = 'object';
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesGetAsync
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesGetAsync($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        return $this->restListingsShippingProfilesGetAsyncWithHttpInfo($page, $items_per_page, $id, $referrer_id, $credentials_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesGetAsyncWithHttpInfo
     *
     * List listing shipping profiles
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {
        $returnType = 'object';
        $request = $this->restListingsShippingProfilesGetRequest($page, $items_per_page, $id, $referrer_id, $credentials_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $id Filter that restricts the search result to listing shipping profiles that match the given ID(s). (optional)
     * @param  int $referrer_id Filter that restricts the search result to listing shipping profiles with given referrer ID(s). (optional)
     * @param  int $credentials_id Filter that restricts the search result to listing shipping profiles with given credential ID(s). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsShippingProfilesGetRequest($page = null, $items_per_page = null, $id = null, $referrer_id = null, $credentials_id = null)
    {

        $resourcePath = '/rest/listings/shipping_profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }
        // query params
        if ($credentials_id !== null) {
            $queryParams['credentialsId'] = ObjectSerializer::toQueryValue($credentials_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsShippingProfilesIdGet
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingShippingProfileModelsShippingProfile
     */
    public function restListingsShippingProfilesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsShippingProfilesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsShippingProfilesIdGetWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingShippingProfileModelsShippingProfile, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsShippingProfilesIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingShippingProfileModelsShippingProfile';
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingShippingProfileModelsShippingProfile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsync
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsync($id, $with = null)
    {
        return $this->restListingsShippingProfilesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsShippingProfilesIdGetAsyncWithHttpInfo
     *
     * Get a shipping profile
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsShippingProfilesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingShippingProfileModelsShippingProfile';
        $request = $this->restListingsShippingProfilesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsShippingProfilesIdGet'
     *
     * @param  int $id The ID of the listing shipping profile entry. (required)
     * @param  int $with An array with child instances to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsShippingProfilesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsShippingProfilesIdGet'
            );
        }

        $resourcePath = '/rest/listings/shipping_profiles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesGet
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsStockDependenceTypesGet($page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restListingsStockDependenceTypesGetWithHttpInfo($page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesGetWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesGetWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsync
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsync($page = null, $items_per_page = null, $with = null)
    {
        return $this->restListingsStockDependenceTypesGetAsyncWithHttpInfo($page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesGetAsyncWithHttpInfo
     *
     * List listing stock dependence types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restListingsStockDependenceTypesGetRequest($page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsStockDependenceTypesGetRequest($page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/listings/stock_dependence_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGet
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingStockDependenceTypeModelsStockDependenceType
     */
    public function restListingsStockDependenceTypesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsStockDependenceTypesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingStockDependenceTypeModelsStockDependenceType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsStockDependenceTypesIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingStockDependenceTypeModelsStockDependenceType';
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingStockDependenceTypeModelsStockDependenceType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsync
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsync($id, $with = null)
    {
        return $this->restListingsStockDependenceTypesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsStockDependenceTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing stock dependence type
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsStockDependenceTypesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingStockDependenceTypeModelsStockDependenceType';
        $request = $this->restListingsStockDependenceTypesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsStockDependenceTypesIdGet'
     *
     * @param  int $id The ID of the listing stock dependence type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsStockDependenceTypesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsStockDependenceTypesIdGet'
            );
        }

        $resourcePath = '/rest/listings/stock_dependence_types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesGet
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restListingsTypesGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restListingsTypesGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restListingsTypesGetWithHttpInfo
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restListingsTypesGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesGetAsync
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesGetAsync($page = null, $items_per_page = null)
    {
        return $this->restListingsTypesGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesGetAsyncWithHttpInfo
     *
     * List listing types
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restListingsTypesGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsTypesGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/listings/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restListingsTypesIdGet
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesListingTypeModelsListingType
     */
    public function restListingsTypesIdGet($id, $with = null)
    {
        list($response) = $this->restListingsTypesIdGetWithHttpInfo($id, $with);
        return $response;
    }

    /**
     * Operation restListingsTypesIdGetWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesListingTypeModelsListingType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restListingsTypesIdGetWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingTypeModelsListingType';
        $request = $this->restListingsTypesIdGetRequest($id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesListingTypeModelsListingType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restListingsTypesIdGetAsync
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesIdGetAsync($id, $with = null)
    {
        return $this->restListingsTypesIdGetAsyncWithHttpInfo($id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restListingsTypesIdGetAsyncWithHttpInfo
     *
     * Get a listing type
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restListingsTypesIdGetAsyncWithHttpInfo($id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesListingTypeModelsListingType';
        $request = $this->restListingsTypesIdGetRequest($id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restListingsTypesIdGet'
     *
     * @param  int $id The ID of the listing type entry. (required)
     * @param  int $with An array with child instances to be loaded. Available values: &#x27;names&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restListingsTypesIdGetRequest($id, $with = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restListingsTypesIdGet'
            );
        }

        $resourcePath = '/rest/listings/types/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
