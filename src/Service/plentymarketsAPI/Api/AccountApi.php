<?php
/**
 * AccountApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * AccountApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restAccountLoginPost
     *
     * Login
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAuthenticationModelsTokenData
     */
    public function restAccountLoginPost($body = null)
    {
        list($response) = $this->restAccountLoginPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountLoginPostWithHttpInfo
     *
     * Login
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAuthenticationModelsTokenData, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAuthenticationModelsTokenData';
        $request = $this->restAccountLoginPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAuthenticationModelsTokenData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginPostAsync
     *
     * Login
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginPostAsync($body = null)
    {
        return $this->restAccountLoginPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginPostAsyncWithHttpInfo
     *
     * Login
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAuthenticationModelsTokenData';
        $request = $this->restAccountLoginPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLoginPostRequest($body = null)
    {

        $resourcePath = '/rest/account/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLoginRefreshPost
     *
     * Refresh
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountLoginRefreshPost()
    {
        $this->restAccountLoginRefreshPostWithHttpInfo();
    }

    /**
     * Operation restAccountLoginRefreshPostWithHttpInfo
     *
     * Refresh
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLoginRefreshPostWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLoginRefreshPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLoginRefreshPostAsync
     *
     * Refresh
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginRefreshPostAsync()
    {
        return $this->restAccountLoginRefreshPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLoginRefreshPostAsyncWithHttpInfo
     *
     * Refresh
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLoginRefreshPostAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLoginRefreshPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLoginRefreshPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLoginRefreshPostRequest()
    {

        $resourcePath = '/rest/account/login/refresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountLogoutPost
     *
     * Logout
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountLogoutPost()
    {
        $this->restAccountLogoutPostWithHttpInfo();
    }

    /**
     * Operation restAccountLogoutPostWithHttpInfo
     *
     * Logout
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountLogoutPostWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLogoutPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountLogoutPostAsync
     *
     * Logout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLogoutPostAsync()
    {
        return $this->restAccountLogoutPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountLogoutPostAsyncWithHttpInfo
     *
     * Logout
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountLogoutPostAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->restAccountLogoutPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountLogoutPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountLogoutPostRequest()
    {

        $resourcePath = '/rest/account/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdContactsGet
     *
     * List contacts
     *
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContact[]
     */
    public function restAccountsAccountIdContactsGet($account_id)
    {
        list($response) = $this->restAccountsAccountIdContactsGetWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContact[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdContactsGetWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact[]';
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsync
     *
     * List contacts
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsync($account_id)
    {
        return $this->restAccountsAccountIdContactsGetAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdContactsGetAsyncWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact[]';
        $request = $this->restAccountsAccountIdContactsGetRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdContactsGet'
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdContactsGetRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdContactsGet'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdDelete
     *
     * Delete an account
     *
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAccountIdDelete($account_id)
    {
        $this->restAccountsAccountIdDeleteWithHttpInfo($account_id);
    }

    /**
     * Operation restAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete an account
     *
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdDeleteWithHttpInfo($account_id)
    {
        $returnType = '';
        $request = $this->restAccountsAccountIdDeleteRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdDeleteAsync
     *
     * Delete an account
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsync($account_id)
    {
        return $this->restAccountsAccountIdDeleteAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete an account
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdDeleteAsyncWithHttpInfo($account_id)
    {
        $returnType = '';
        $request = $this->restAccountsAccountIdDeleteRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdDelete'
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdDeleteRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdGet
     *
     * Get an account
     *
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsAccountIdGet($account_id)
    {
        list($response) = $this->restAccountsAccountIdGetWithHttpInfo($account_id);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdGetWithHttpInfo
     *
     * Get an account
     *
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdGetWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsAccountIdGetRequest($account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdGetAsync
     *
     * Get an account
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdGetAsync($account_id)
    {
        return $this->restAccountsAccountIdGetAsyncWithHttpInfo($account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get an account
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdGetAsyncWithHttpInfo($account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsAccountIdGetRequest($account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdGet'
     *
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdGetRequest($account_id)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdGet'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAccountIdPut
     *
     * Update an account
     *
     * @param  int $account_id account_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsAccountIdPut($account_id, $body = null)
    {
        list($response) = $this->restAccountsAccountIdPutWithHttpInfo($account_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsAccountIdPutWithHttpInfo
     *
     * Update an account
     *
     * @param  int $account_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAccountIdPutWithHttpInfo($account_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsAccountIdPutRequest($account_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAccountIdPutAsync
     *
     * Update an account
     *
     * @param  int $account_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdPutAsync($account_id, $body = null)
    {
        return $this->restAccountsAccountIdPutAsyncWithHttpInfo($account_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update an account
     *
     * @param  int $account_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAccountIdPutAsyncWithHttpInfo($account_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsAccountIdPutRequest($account_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAccountIdPut'
     *
     * @param  int $account_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAccountIdPutRequest($account_id, $body = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsAccountIdPut'
            );
        }

        $resourcePath = '/rest/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdDelete
     *
     * Delete an address
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdDelete($address_id)
    {
        $this->restAccountsAddressesAddressIdDeleteWithHttpInfo($address_id);
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete an address
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdDeleteWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsync
     *
     * Delete an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdDeleteAsyncWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdDeleteRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdDelete'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdDeleteRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdGet
     *
     * Get an address
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsAddressesAddressIdGet($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdGetWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdGetWithHttpInfo
     *
     * Get an address
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdGetWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsync
     *
     * Get an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdGetAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdGetAsyncWithHttpInfo
     *
     * Get an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdGetAsyncWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdGetRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdGet'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdGetRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDelete
     *
     * Delete an address option by the address ID
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesAddressIdOptionsDelete($address_id)
    {
        $this->restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo($address_id);
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo
     *
     * Delete an address option by the address ID
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsDeleteWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsync
     *
     * Delete an address option by the address ID
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete an address option by the address ID
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsDeleteAsyncWithHttpInfo($address_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesAddressIdOptionsDeleteRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsDelete'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsDeleteRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGet
     *
     * List address options
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsGet($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsGetWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsGetWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsync
     *
     * List address options
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo
     *
     * List address options
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsGetAsyncWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsGetRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsGet'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsGetRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPost
     *
     * Create an address option
     *
     * @param  int $address_id address_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPost($address_id, $body = null)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPostWithHttpInfo($address_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostWithHttpInfo
     *
     * Create an address option
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPostWithHttpInfo($address_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsync
     *
     * Create an address option
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsync($address_id, $body = null)
    {
        return $this->restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo($address_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo
     *
     * Create an address option
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPostAsyncWithHttpInfo($address_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPostRequest($address_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPost'
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsPostRequest($address_id, $body = null)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPost'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPut
     *
     * Update the address options for an address
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]
     */
    public function restAccountsAddressesAddressIdOptionsPut($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdOptionsPutWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutWithHttpInfo
     *
     * Update the address options for an address
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdOptionsPutWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsync
     *
     * Update the address options for an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo
     *
     * Update the address options for an address
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdOptionsPutAsyncWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption[]';
        $request = $this->restAccountsAddressesAddressIdOptionsPutRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdOptionsPut'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdOptionsPutRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdOptionsPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdPut
     *
     * Update an address
     *
     * @param  int $address_id address_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsAddressesAddressIdPut($address_id, $body = null)
    {
        list($response) = $this->restAccountsAddressesAddressIdPutWithHttpInfo($address_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdPutWithHttpInfo
     *
     * Update an address
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdPutWithHttpInfo($address_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsync
     *
     * Update an address
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsync($address_id, $body = null)
    {
        return $this->restAccountsAddressesAddressIdPutAsyncWithHttpInfo($address_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update an address
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdPutAsyncWithHttpInfo($address_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdPutRequest($address_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdPut'
     *
     * @param  int $address_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdPutRequest($address_id, $body = null)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGet
     *
     * Find address data by address id
     *
     * @param  int $address_id address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsAddressesAddressIdRelatedDataGet($address_id)
    {
        list($response) = $this->restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo($address_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo
     *
     * Find address data by address id
     *
     * @param  int $address_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesAddressIdRelatedDataGetWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsync
     *
     * Find address data by address id
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsync($address_id)
    {
        return $this->restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo($address_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo
     *
     * Find address data by address id
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesAddressIdRelatedDataGetAsyncWithHttpInfo($address_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesAddressIdRelatedDataGetRequest($address_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesAddressIdRelatedDataGet'
     *
     * @param  int $address_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesAddressIdRelatedDataGetRequest($address_id)
    {
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsAddressesAddressIdRelatedDataGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/{addressId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDelete
     *
     * Delete an address contact relation
     *
     * @param  int $address_contact_relation_id address_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDelete($address_contact_relation_id)
    {
        $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo($address_contact_relation_id);
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo
     *
     * Delete an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync
     *
     * Delete an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsync($address_contact_relation_id)
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo($address_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteAsyncWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsAddressContactRelationIdDeleteRequest($address_contact_relation_id)
    {
        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGet
     *
     * Get an address contact relation
     *
     * @param  int $address_contact_relation_id address_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGet($address_contact_relation_id)
    {
        list($response) = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo($address_contact_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo
     *
     * Get an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync
     *
     * Get an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsync($address_contact_relation_id)
    {
        return $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo($address_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo
     *
     * Get an address contact relation
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsAddressContactRelationIdGetAsyncWithHttpInfo($address_contact_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsAddressContactRelationIdGet'
     *
     * @param  int $address_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsAddressContactRelationIdGetRequest($address_contact_relation_id)
    {
        // verify the required parameter 'address_contact_relation_id' is set
        if ($address_contact_relation_id === null || (is_array($address_contact_relation_id) && count($address_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_contact_relation_id when calling restAccountsAddressesContactRelationsAddressContactRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/contact_relations/{addressContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressContactRelationId' . '}',
                ObjectSerializer::toPathValue($address_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGet
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsAddressesContactRelationsGet($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsGetWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsGetWithHttpInfo($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsync
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsync($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        return $this->restAccountsAddressesContactRelationsGetAsyncWithHttpInfo($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsGetAsyncWithHttpInfo
     *
     * List address contact relations
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsGetAsyncWithHttpInfo($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesContactRelationsGetRequest($id, $contact_id, $type_id, $address_id, $is_primary, $page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsGet'
     *
     * @param  int $id Filter that restricts the search result to address contact relations with a specific ID (optional)
     * @param  int $contact_id Filter that restricts the search result to contacts with a specific ID (optional)
     * @param  int $type_id Filter that restricts the search result to address types with a specific ID (optional)
     * @param  int $address_id Filter that restricts the search result to addresses with a specific ID (optional)
     * @param  bool $is_primary Filter that restricts the search result depending on the flag used. If the flag isPrimary&#x3D;true is set, the filter restricts the search result to addresses that are primary addresses. If the flag isPrimary&#x3D;false is set, the filter restricts the search results to addresses that are not primary addresses. If no flag is set, both primary and non-primary addresses are listed. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $with Includes the specified address contact relation information in the results. The following parameters are available: contact and address. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsGetRequest($id = null, $contact_id = null, $type_id = null, $address_id = null, $is_primary = null, $page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }
        // query params
        if ($address_id !== null) {
            $queryParams['addressId'] = ObjectSerializer::toQueryValue($address_id);
        }
        // query params
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = ObjectSerializer::toQueryValue($is_primary);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPost
     *
     * Create address contact relations
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPost($body = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsync
     *
     * Create address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsync($body = null)
    {
        return $this->restAccountsAddressesContactRelationsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPostAsyncWithHttpInfo
     *
     * Create address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPut
     *
     * Update address contact relations
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]
     */
    public function restAccountsAddressesContactRelationsPut($body = null)
    {
        list($response) = $this->restAccountsAddressesContactRelationsPutWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesContactRelationsPutWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPutRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsync
     *
     * Update address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsync($body = null)
    {
        return $this->restAccountsAddressesContactRelationsPutAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesContactRelationsPutAsyncWithHttpInfo
     *
     * Update address contact relations
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesContactRelationsPutAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation[]';
        $request = $this->restAccountsAddressesContactRelationsPutRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesContactRelationsPut'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesContactRelationsPutRequest($body = null)
    {

        $resourcePath = '/rest/accounts/addresses/contact_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGet
     *
     * List address option types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType[]
     */
    public function restAccountsAddressesOptionTypesGet()
    {
        list($response) = $this->restAccountsAddressesOptionTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetWithHttpInfo
     *
     * List address option types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType[]';
        $request = $this->restAccountsAddressesOptionTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsync
     *
     * List address option types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsync()
    {
        return $this->restAccountsAddressesOptionTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesGetAsyncWithHttpInfo
     *
     * List address option types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType[]';
        $request = $this->restAccountsAddressesOptionTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDelete
     *
     * Delete an address option type
     *
     * @param  int $option_type_id option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDelete($option_type_id)
    {
        $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id);
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsync($option_type_id)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdDeleteRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGet
     *
     * Get an address option type
     *
     * @param  int $option_type_id option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGet($option_type_id)
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsync
     *
     * Get an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsync($option_type_id)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get an address option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdGetRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPut
     *
     * Update an address option type
     *
     * @param  int $option_type_id option_type_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPut($option_type_id, $body = null)
    {
        list($response) = $this->restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update an address option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsync
     *
     * Update an address option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsync($option_type_id, $body = null)
    {
        return $this->restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update an address option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesOptionTypeIdPutRequest($option_type_id, $body = null)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsAddressesOptionTypesOptionTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPost
     *
     * Create an address option type
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType
     */
    public function restAccountsAddressesOptionTypesPost($body = null)
    {
        list($response) = $this->restAccountsAddressesOptionTypesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostWithHttpInfo
     *
     * Create an address option type
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionTypesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsync
     *
     * Create an address option type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsync($body = null)
    {
        return $this->restAccountsAddressesOptionTypesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionTypesPostAsyncWithHttpInfo
     *
     * Create an address option type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionTypesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOptionType';
        $request = $this->restAccountsAddressesOptionTypesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionTypesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionTypesPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/addresses/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDelete
     *
     * Delete an address option by the option ID
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesOptionsOptionIdDelete($option_id)
    {
        $this->restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo($option_id);
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete an address option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdDeleteWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsync
     *
     * Delete an address option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete an address option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesOptionsOptionIdDeleteRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdDelete'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdDeleteRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGet
     *
     * Get an address option
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption
     */
    public function restAccountsAddressesOptionsOptionIdGet($option_id)
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdGetWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetWithHttpInfo
     *
     * Get an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdGetWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsync
     *
     * Get an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdGetAsyncWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdGetRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdGet'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdGetRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPut
     *
     * Update an address option
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption
     */
    public function restAccountsAddressesOptionsOptionIdPut($option_id)
    {
        list($response) = $this->restAccountsAddressesOptionsOptionIdPutWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutWithHttpInfo
     *
     * Update an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesOptionsOptionIdPutWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsync
     *
     * Update an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsync($option_id)
    {
        return $this->restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update an address option
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesOptionsOptionIdPutAsyncWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOption';
        $request = $this->restAccountsAddressesOptionsOptionIdPutRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesOptionsOptionIdPut'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesOptionsOptionIdPutRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsAddressesOptionsOptionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDelete
     *
     * Delete an address POS relation
     *
     * @param  int $address_pos_relation_id address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDelete($address_pos_relation_id)
    {
        $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo($address_pos_relation_id);
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo
     *
     * Delete an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync
     *
     * Delete an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdDeleteRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGet
     *
     * Get an address POS relation
     *
     * @param  int $address_pos_relation_id address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGet($address_pos_relation_id)
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo($address_pos_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo
     *
     * Get an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync
     *
     * Get an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo
     *
     * Get an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdGetAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdGet'
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdGetRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPut
     *
     * Update an address POS relation
     *
     * @param  int $address_pos_relation_id address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPut($address_pos_relation_id)
    {
        list($response) = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo($address_pos_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo
     *
     * Update an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync
     *
     * Update an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsync($address_pos_relation_id)
    {
        return $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo($address_pos_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo
     *
     * Update an address POS relation
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsAddressPosRelationIdPutAsyncWithHttpInfo($address_pos_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsAddressPosRelationIdPut'
     *
     * @param  int $address_pos_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsAddressPosRelationIdPutRequest($address_pos_relation_id)
    {
        // verify the required parameter 'address_pos_relation_id' is set
        if ($address_pos_relation_id === null || (is_array($address_pos_relation_id) && count($address_pos_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_pos_relation_id when calling restAccountsAddressesPosRelationsAddressPosRelationIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/pos_relations/{addressPosRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($address_pos_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressPosRelationId' . '}',
                ObjectSerializer::toPathValue($address_pos_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGet
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsAddressesPosRelationsGet($page = null, $items_per_page = null, $with = null)
    {
        list($response) = $this->restAccountsAddressesPosRelationsGetWithHttpInfo($page, $items_per_page, $with);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsGetWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsync
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsync($page = null, $items_per_page = null, $with = null)
    {
        return $this->restAccountsAddressesPosRelationsGetAsyncWithHttpInfo($page, $items_per_page, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsGetAsyncWithHttpInfo
     *
     * List address POS relations
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsAddressesPosRelationsGetRequest($page, $items_per_page, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsGet'
     *
     * @param  int $page page (optional)
     * @param  int $items_per_page items per page (optional)
     * @param  string $with Includes the specified address pos relation information in the results. The following parameters are available: address and type. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsGetRequest($page = null, $items_per_page = null, $with = null)
    {

        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPost
     *
     * Create an address POS relation
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation
     */
    public function restAccountsAddressesPosRelationsPost()
    {
        list($response) = $this->restAccountsAddressesPosRelationsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostWithHttpInfo
     *
     * Create an address POS relation
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPosRelationsPostWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsync
     *
     * Create an address POS relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsync()
    {
        return $this->restAccountsAddressesPosRelationsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPosRelationsPostAsyncWithHttpInfo
     *
     * Create an address POS relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPosRelationsPostAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressPosRelation';
        $request = $this->restAccountsAddressesPosRelationsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPosRelationsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPosRelationsPostRequest()
    {

        $resourcePath = '/rest/accounts/addresses/pos_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesPost
     *
     * Create an address
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsAddressesPost($body = null)
    {
        list($response) = $this->restAccountsAddressesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsAddressesPostWithHttpInfo
     *
     * Create an address
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesPostAsync
     *
     * Create an address
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPostAsync($body = null)
    {
        return $this->restAccountsAddressesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesPostAsyncWithHttpInfo
     *
     * Create an address
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsAddressesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGet
     *
     * List address relation types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressRelationType[]
     */
    public function restAccountsAddressesRelationTypesGet()
    {
        list($response) = $this->restAccountsAddressesRelationTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetWithHttpInfo
     *
     * List address relation types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressRelationType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationTypesGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressRelationType[]';
        $request = $this->restAccountsAddressesRelationTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressRelationType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsync
     *
     * List address relation types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsync()
    {
        return $this->restAccountsAddressesRelationTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationTypesGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressRelationType[]';
        $request = $this->restAccountsAddressesRelationTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesRelationTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/addresses/relation_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGet
     *
     * List address relation types
     *
     * @param  int $application application (required)
     * @param  int $lang lang (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\IlluminateDatabaseEloquentCollection
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGet($application, $lang)
    {
        list($response) = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo($application, $lang);
        return $response;
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo
     *
     * List address relation types
     *
     * @param  int $application (required)
     * @param  int $lang (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\IlluminateDatabaseEloquentCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetWithHttpInfo($application, $lang)
    {
        $returnType = '\Swagger\Client\Model\IlluminateDatabaseEloquentCollection';
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\IlluminateDatabaseEloquentCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync
     *
     * List address relation types
     *
     * @param  int $application (required)
     * @param  int $lang (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsync($application, $lang)
    {
        return $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo($application, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo
     *
     * List address relation types
     *
     * @param  int $application (required)
     * @param  int $lang (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetAsyncWithHttpInfo($application, $lang)
    {
        $returnType = '\Swagger\Client\Model\IlluminateDatabaseEloquentCollection';
        $request = $this->restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
     *
     * @param  int $application (required)
     * @param  int $lang (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesRelationsTypesApplicationsApplicationLangGetRequest($application, $lang)
    {
        // verify the required parameter 'application' is set
        if ($application === null || (is_array($application) && count($application) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }
        // verify the required parameter 'lang' is set
        if ($lang === null || (is_array($lang) && count($lang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lang when calling restAccountsAddressesRelationsTypesApplicationsApplicationLangGet'
            );
        }

        $resourcePath = '/rest/accounts/addresses/relations/types/applications/{application}/{lang}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($application !== null) {
            $resourcePath = str_replace(
                '{' . 'application' . '}',
                ObjectSerializer::toPathValue($application),
                $resourcePath
            );
        }
        // path params
        if ($lang !== null) {
            $resourcePath = str_replace(
                '{' . 'lang' . '}',
                ObjectSerializer::toPathValue($lang),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPost
     *
     * Create an address warehouse relation
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsPost()
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostWithHttpInfo
     *
     * Create an address warehouse relation
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsPostWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsync
     *
     * Create an address warehouse relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsync()
    {
        return $this->restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo
     *
     * Create an address warehouse relation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsPostAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsPostRequest()
    {

        $resourcePath = '/rest/accounts/addresses/warehouse_relations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDelete
     *
     * Delete an address warehouse relation
     *
     * @param  int $relation_id relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDelete($relation_id)
    {
        $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo($relation_id);
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo
     *
     * Delete an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync
     *
     * Delete an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsync($relation_id)
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo
     *
     * Delete an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdDeleteAsyncWithHttpInfo($relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdDelete'
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsRelationIdDeleteRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPut
     *
     * Update an address warehouse relation
     *
     * @param  int $relation_id relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPut($relation_id)
    {
        list($response) = $this->restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo($relation_id);
        return $response;
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo
     *
     * Update an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutWithHttpInfo($relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsync
     *
     * Update an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsync($relation_id)
    {
        return $this->restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo
     *
     * Update an address warehouse relation
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsAddressesWarehouseRelationsRelationIdPutAsyncWithHttpInfo($relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsAddressesWarehouseRelationsRelationIdPut'
     *
     * @param  int $relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsAddressesWarehouseRelationsRelationIdPutRequest($relation_id)
    {
        // verify the required parameter 'relation_id' is set
        if ($relation_id === null || (is_array($relation_id) && count($relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_id when calling restAccountsAddressesWarehouseRelationsRelationIdPut'
            );
        }

        $resourcePath = '/rest/accounts/addresses/warehouse_relations/{relationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationId' . '}',
                ObjectSerializer::toPathValue($relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDelete
     *
     * Deletes an account contact relation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id account_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactRelationsAccountContactRelationIdDelete($account_contact_relation_id)
    {
        $this->restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo($account_contact_relation_id);
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo
     *
     * Deletes an account contact relation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsync
     *
     * Deletes an account contact relation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsync($account_contact_relation_id)
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo($account_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo
     *
     * Deletes an account contact relation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdDeleteAsyncWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdDelete'
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactRelationsAccountContactRelationIdDeleteRequest($account_contact_relation_id)
    {
        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGet
     *
     * Gets an account contact releation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id account_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccountContactRelation
     */
    public function restAccountsContactRelationsAccountContactRelationIdGet($account_contact_relation_id)
    {
        list($response) = $this->restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo($account_contact_relation_id);
        return $response;
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo
     *
     * Gets an account contact releation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccountContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccountContactRelation';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccountContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsync
     *
     * Gets an account contact releation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsync($account_contact_relation_id)
    {
        return $this->restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo($account_contact_relation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo
     *
     * Gets an account contact releation. The ID of the account contact relation must be specified.
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactRelationsAccountContactRelationIdGetAsyncWithHttpInfo($account_contact_relation_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccountContactRelation';
        $request = $this->restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactRelationsAccountContactRelationIdGet'
     *
     * @param  int $account_contact_relation_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactRelationsAccountContactRelationIdGetRequest($account_contact_relation_id)
    {
        // verify the required parameter 'account_contact_relation_id' is set
        if ($account_contact_relation_id === null || (is_array($account_contact_relation_id) && count($account_contact_relation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_contact_relation_id when calling restAccountsContactRelationsAccountContactRelationIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contact_relations/{accountContactRelationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_contact_relation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountContactRelationId' . '}',
                ObjectSerializer::toPathValue($account_contact_relation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDelete
     *
     * Delete a bank account
     *
     * @param  int $contact_bank_id contact_bank_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsBanksContactBankIdDelete($contact_bank_id)
    {
        $this->restAccountsContactsBanksContactBankIdDeleteWithHttpInfo($contact_bank_id);
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteWithHttpInfo
     *
     * Delete a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdDeleteWithHttpInfo($contact_bank_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsync
     *
     * Delete a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsync($contact_bank_id)
    {
        return $this->restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo($contact_bank_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo
     *
     * Delete a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdDeleteAsyncWithHttpInfo($contact_bank_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdDelete'
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdDeleteRequest($contact_bank_id)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGet
     *
     * Get a bank account
     *
     * @param  int $contact_bank_id contact_bank_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank
     */
    public function restAccountsContactsBanksContactBankIdGet($contact_bank_id)
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdGetWithHttpInfo($contact_bank_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetWithHttpInfo
     *
     * Get a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdGetWithHttpInfo($contact_bank_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsync
     *
     * Get a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsync($contact_bank_id)
    {
        return $this->restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo($contact_bank_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo
     *
     * Get a bank account
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdGetAsyncWithHttpInfo($contact_bank_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdGet'
     *
     * @param  int $contact_bank_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdGetRequest($contact_bank_id)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPut
     *
     * Update a bank account
     *
     * @param  int $contact_bank_id contact_bank_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank
     */
    public function restAccountsContactsBanksContactBankIdPut($contact_bank_id, $body = null)
    {
        list($response) = $this->restAccountsContactsBanksContactBankIdPutWithHttpInfo($contact_bank_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutWithHttpInfo
     *
     * Update a bank account
     *
     * @param  int $contact_bank_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksContactBankIdPutWithHttpInfo($contact_bank_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsync
     *
     * Update a bank account
     *
     * @param  int $contact_bank_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsync($contact_bank_id, $body = null)
    {
        return $this->restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo($contact_bank_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo
     *
     * Update a bank account
     *
     * @param  int $contact_bank_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksContactBankIdPutAsyncWithHttpInfo($contact_bank_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksContactBankIdPut'
     *
     * @param  int $contact_bank_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksContactBankIdPutRequest($contact_bank_id, $body = null)
    {
        // verify the required parameter 'contact_bank_id' is set
        if ($contact_bank_id === null || (is_array($contact_bank_id) && count($contact_bank_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_bank_id when calling restAccountsContactsBanksContactBankIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/banks/{contactBankId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_bank_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactBankId' . '}',
                ObjectSerializer::toPathValue($contact_bank_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsBanksPost
     *
     * Create a bank account
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank
     */
    public function restAccountsContactsBanksPost($body = null)
    {
        list($response) = $this->restAccountsContactsBanksPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsBanksPostWithHttpInfo
     *
     * Create a bank account
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsBanksPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsBanksPostAsync
     *
     * Create a bank account
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksPostAsync($body = null)
    {
        return $this->restAccountsContactsBanksPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsBanksPostAsyncWithHttpInfo
     *
     * Create a bank account
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsBanksPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank';
        $request = $this->restAccountsContactsBanksPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsBanksPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsBanksPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGet
     *
     * Get a contact class
     *
     * @param  int $contact_class_id contact_class_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function restAccountsContactsClassesContactClassIdGet($contact_class_id)
    {
        list($response) = $this->restAccountsContactsClassesContactClassIdGetWithHttpInfo($contact_class_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetWithHttpInfo
     *
     * Get a contact class
     *
     * @param  int $contact_class_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesContactClassIdGetWithHttpInfo($contact_class_id)
    {
        $returnType = 'string';
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsync
     *
     * Get a contact class
     *
     * @param  int $contact_class_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsync($contact_class_id)
    {
        return $this->restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo($contact_class_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo
     *
     * Get a contact class
     *
     * @param  int $contact_class_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesContactClassIdGetAsyncWithHttpInfo($contact_class_id)
    {
        $returnType = 'string';
        $request = $this->restAccountsContactsClassesContactClassIdGetRequest($contact_class_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesContactClassIdGet'
     *
     * @param  int $contact_class_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsClassesContactClassIdGetRequest($contact_class_id)
    {
        // verify the required parameter 'contact_class_id' is set
        if ($contact_class_id === null || (is_array($contact_class_id) && count($contact_class_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_class_id when calling restAccountsContactsClassesContactClassIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/classes/{contactClassId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_class_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactClassId' . '}',
                ObjectSerializer::toPathValue($contact_class_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsClassesGet
     *
     * List contact classes
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function restAccountsContactsClassesGet()
    {
        list($response) = $this->restAccountsContactsClassesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsClassesGetWithHttpInfo
     *
     * List contact classes
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsClassesGetWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->restAccountsContactsClassesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsClassesGetAsync
     *
     * List contact classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesGetAsync()
    {
        return $this->restAccountsContactsClassesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsClassesGetAsyncWithHttpInfo
     *
     * List contact classes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsClassesGetAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->restAccountsContactsClassesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsClassesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsClassesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/classes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDelete
     *
     * Delete a contact event
     *
     * @param  int $contact_event_id contact_event_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactEventsContactEventIdDelete($contact_event_id)
    {
        $this->restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo($contact_event_id);
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo
     *
     * Delete a contact event
     *
     * @param  int $contact_event_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteWithHttpInfo($contact_event_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsync
     *
     * Delete a contact event
     *
     * @param  int $contact_event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsync($contact_event_id)
    {
        return $this->restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo($contact_event_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact event
     *
     * @param  int $contact_event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdDeleteAsyncWithHttpInfo($contact_event_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdDelete'
     *
     * @param  int $contact_event_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsContactEventIdDeleteRequest($contact_event_id)
    {
        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPut
     *
     * Update a contact event
     *
     * @param  int $contact_event_id contact_event_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent
     */
    public function restAccountsContactsContactEventsContactEventIdPut($contact_event_id, $body = null)
    {
        list($response) = $this->restAccountsContactsContactEventsContactEventIdPutWithHttpInfo($contact_event_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutWithHttpInfo
     *
     * Update a contact event
     *
     * @param  int $contact_event_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsContactEventIdPutWithHttpInfo($contact_event_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent';
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsync
     *
     * Update a contact event
     *
     * @param  int $contact_event_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsync($contact_event_id, $body = null)
    {
        return $this->restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo($contact_event_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo
     *
     * Update a contact event
     *
     * @param  int $contact_event_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsContactEventIdPutAsyncWithHttpInfo($contact_event_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent';
        $request = $this->restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsContactEventIdPut'
     *
     * @param  int $contact_event_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsContactEventIdPutRequest($contact_event_id, $body = null)
    {
        // verify the required parameter 'contact_event_id' is set
        if ($contact_event_id === null || (is_array($contact_event_id) && count($contact_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_event_id when calling restAccountsContactsContactEventsContactEventIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/contact_events/{contactEventId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactEventId' . '}',
                ObjectSerializer::toPathValue($contact_event_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsGet
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactEventsGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactEventsGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsGetWithHttpInfo
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsync
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsync($page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactEventsGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsGetAsyncWithHttpInfo
     *
     * List contact events
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactEventsGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsGet'
     *
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsPost
     *
     * Create a contact event
     *
     * @param  object $body body (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent
     */
    public function restAccountsContactsContactEventsPost($body = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactEventsPostWithHttpInfo($body, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsPostWithHttpInfo
     *
     * Create a contact event
     *
     * @param  object $body (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsPostWithHttpInfo($body = null, $page = null, $items_per_page = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent';
        $request = $this->restAccountsContactsContactEventsPostRequest($body, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsync
     *
     * Create a contact event
     *
     * @param  object $body (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsync($body = null, $page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactEventsPostAsyncWithHttpInfo($body, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsPostAsyncWithHttpInfo
     *
     * Create a contact event
     *
     * @param  object $body (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsPostAsyncWithHttpInfo($body = null, $page = null, $items_per_page = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactContactEventModelsContactEvent';
        $request = $this->restAccountsContactsContactEventsPostRequest($body, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsPost'
     *
     * @param  object $body (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsPostRequest($body = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounts/contacts/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGet
     *
     * Get the contact event types as a key/value array.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Mixed[]
     */
    public function restAccountsContactsContactEventsTypesPreviewGet()
    {
        list($response) = $this->restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo
     *
     * Get the contact event types as a key/value array.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Mixed[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactEventsTypesPreviewGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Mixed[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsync
     *
     * Get the contact event types as a key/value array.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsync()
    {
        return $this->restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo
     *
     * Get the contact event types as a key/value array.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactEventsTypesPreviewGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\Mixed[]';
        $request = $this->restAccountsContactsContactEventsTypesPreviewGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactEventsTypesPreviewGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactEventsTypesPreviewGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/contact_events/types/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGet
     *
     * Get the login URL
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGet($contact_id)
    {
        $this->restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo($contact_id);
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo
     *
     * Get the login URL
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsync
     *
     * Get the login URL
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo
     *
     * Get the login URL
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataLoginUrlGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataLoginUrlGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataLoginUrlGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataLoginUrlGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/login_url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPut
     *
     * Send password link for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPut($password, $contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo($password, $contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo
     *
     * Send password link for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutWithHttpInfo($password, $contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsync
     *
     * Send password link for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsync($password, $contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo($password, $contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo
     *
     * Send password link for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataNewPasswordPutAsyncWithHttpInfo($password, $contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataNewPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataNewPasswordPutRequest($password, $contact_id)
    {
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataNewPasswordPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/new_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPut
     *
     * Update the password for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPut($password, $contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo($password, $contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo
     *
     * Update the password for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutWithHttpInfo($password, $contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsync
     *
     * Update the password for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsync($password, $contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo($password, $contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo
     *
     * Update the password for a contact
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataSetPasswordPutAsyncWithHttpInfo($password, $contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataSetPasswordPut'
     *
     * @param  string $password The new password (required)
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataSetPasswordPutRequest($password, $contact_id)
    {
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataSetPasswordPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/set_password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPut
     *
     * Unblock a contact
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPut($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo
     *
     * Unblock a contact
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsync
     *
     * Unblock a contact
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo
     *
     * Unblock a contact
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccessDataUnblockUserPutAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccessDataUnblockUserPut'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccessDataUnblockUserPutRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccessDataUnblockUserPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/access_data/unblock_user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDelete
     *
     * Delete an account of the contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAccountsAccountIdDelete($contact_id, $account_id)
    {
        $this->restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo($contact_id, $account_id);
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo
     *
     * Delete an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsync
     *
     * Delete an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo
     *
     * Delete an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdDeleteAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdDelete'
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdDeleteRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGet
     *
     * Get an account of the contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsContactsContactIdAccountsAccountIdGet($contact_id, $account_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo($contact_id, $account_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo
     *
     * Get an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsync
     *
     * Get an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get an account of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdGetAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdGet'
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdGetRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPut
     *
     * Update an account
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsContactsContactIdAccountsAccountIdPut($contact_id, $account_id)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo($contact_id, $account_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo
     *
     * Update an account
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsync
     *
     * Update an account
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsync($contact_id, $account_id)
    {
        return $this->restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo($contact_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo
     *
     * Update an account
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsAccountIdPutAsyncWithHttpInfo($contact_id, $account_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsAccountIdPut'
     *
     * @param  int $contact_id (required)
     * @param  int $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsAccountIdPutRequest($contact_id, $account_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling restAccountsContactsContactIdAccountsAccountIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPost
     *
     * Create an account for existing contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsContactsContactIdAccountsPost($contact_id, $body = null)
    {
        list($response) = $this->restAccountsContactsContactIdAccountsPostWithHttpInfo($contact_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostWithHttpInfo
     *
     * Create an account for existing contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAccountsPostWithHttpInfo($contact_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsync
     *
     * Create an account for existing contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsync($contact_id, $body = null)
    {
        return $this->restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo($contact_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo
     *
     * Create an account for existing contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAccountsPostAsyncWithHttpInfo($contact_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsContactsContactIdAccountsPostRequest($contact_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAccountsPost'
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAccountsPostRequest($contact_id, $body = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAccountsPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDelete
     *
     * Delete an address of the contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $address_id address_id (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdAddressesAddressIdDelete($contact_id, $address_id, $type_id = null)
    {
        $this->restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo($contact_id, $address_id, $type_id);
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo
     *
     * Delete an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteWithHttpInfo($contact_id, $address_id, $type_id = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsync
     *
     * Delete an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsync($contact_id, $address_id, $type_id = null)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo($contact_id, $address_id, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo
     *
     * Delete an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdDeleteAsyncWithHttpInfo($contact_id, $address_id, $type_id = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdDelete'
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdDeleteRequest($contact_id, $address_id, $type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPut
     *
     * Update an address of the contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $address_id address_id (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsContactsContactIdAddressesAddressIdPut($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo($contact_id, $address_id, $is_primary, $type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo
     *
     * Update an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutWithHttpInfo($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsync
     *
     * Update an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsync($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo($contact_id, $address_id, $is_primary, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update an address of the contact
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdPutAsyncWithHttpInfo($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdPut'
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdPutRequest($contact_id, $address_id, $is_primary = null, $type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = ObjectSerializer::toQueryValue($is_primary);
        }
        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut
     *
     * Set a contact address per address type as the primary address
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $address_id address_id (required)
     * @param  int $address_type_id address_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut($contact_id, $address_id, $address_type_id)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo
     *
     * Set a contact address per address type as the primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync
     *
     * Set a contact address per address type as the primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsync($contact_id, $address_id, $address_type_id)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo
     *
     * Set a contact address per address type as the primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPutRequest($contact_id, $address_id, $address_type_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }
        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdPrimaryPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut
     *
     * Resets a contact primary address
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $address_id address_id (required)
     * @param  int $address_type_id address_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut($contact_id, $address_id, $address_type_id)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo
     *
     * Resets a contact primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync
     *
     * Resets a contact primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsync($contact_id, $address_id, $address_type_id)
    {
        return $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo
     *
     * Resets a contact primary address
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutAsyncWithHttpInfo($contact_id, $address_id, $address_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressContactRelation';
        $request = $this->restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
     *
     * @param  int $contact_id (required)
     * @param  int $address_id (required)
     * @param  int $address_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPutRequest($contact_id, $address_id, $address_type_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }
        // verify the required parameter 'address_id' is set
        if ($address_id === null || (is_array($address_id) && count($address_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }
        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressIdTypesAddressTypeIdResetPrimaryPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressId}/types/{addressTypeId}/reset_primary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($address_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressTypeIdGet
     *
     * List addresses that are linked with contacts
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $address_type_id address_type_id (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of addresses to list per page. The default number is 1000. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress[]
     */
    public function restAccountsContactsContactIdAddressesAddressTypeIdGet($contact_id, $address_type_id, $page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesAddressTypeIdGetWithHttpInfo($contact_id, $address_type_id, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressTypeIdGetWithHttpInfo
     *
     * List addresses that are linked with contacts
     *
     * @param  int $contact_id (required)
     * @param  int $address_type_id (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of addresses to list per page. The default number is 1000. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesAddressTypeIdGetWithHttpInfo($contact_id, $address_type_id, $page = null, $items_per_page = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress[]';
        $request = $this->restAccountsContactsContactIdAddressesAddressTypeIdGetRequest($contact_id, $address_type_id, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressTypeIdGetAsync
     *
     * List addresses that are linked with contacts
     *
     * @param  int $contact_id (required)
     * @param  int $address_type_id (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of addresses to list per page. The default number is 1000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressTypeIdGetAsync($contact_id, $address_type_id, $page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactIdAddressesAddressTypeIdGetAsyncWithHttpInfo($contact_id, $address_type_id, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesAddressTypeIdGetAsyncWithHttpInfo
     *
     * List addresses that are linked with contacts
     *
     * @param  int $contact_id (required)
     * @param  int $address_type_id (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of addresses to list per page. The default number is 1000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesAddressTypeIdGetAsyncWithHttpInfo($contact_id, $address_type_id, $page = null, $items_per_page = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress[]';
        $request = $this->restAccountsContactsContactIdAddressesAddressTypeIdGetRequest($contact_id, $address_type_id, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesAddressTypeIdGet'
     *
     * @param  int $contact_id (required)
     * @param  int $address_type_id (required)
     * @param  int $page The requested page. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of addresses to list per page. The default number is 1000. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesAddressTypeIdGetRequest($contact_id, $address_type_id, $page = null, $items_per_page = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesAddressTypeIdGet'
            );
        }
        // verify the required parameter 'address_type_id' is set
        if ($address_type_id === null || (is_array($address_type_id) && count($address_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address_type_id when calling restAccountsContactsContactIdAddressesAddressTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses/{addressTypeId?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }
        // path params
        if ($address_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'addressTypeId?' . '}',
                ObjectSerializer::toPathValue($address_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPost
     *
     * Create an address for existing contact and type
     *
     * @param  int $contact_id contact_id (required)
     * @param  object $body body (optional)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress
     */
    public function restAccountsContactsContactIdAddressesPost($contact_id, $body = null, $is_primary = null, $type_id = null)
    {
        list($response) = $this->restAccountsContactsContactIdAddressesPostWithHttpInfo($contact_id, $body, $is_primary, $type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostWithHttpInfo
     *
     * Create an address for existing contact and type
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdAddressesPostWithHttpInfo($contact_id, $body = null, $is_primary = null, $type_id = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $body, $is_primary, $type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsync
     *
     * Create an address for existing contact and type
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsync($contact_id, $body = null, $is_primary = null, $type_id = null)
    {
        return $this->restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo($contact_id, $body, $is_primary, $type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo
     *
     * Create an address for existing contact and type
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdAddressesPostAsyncWithHttpInfo($contact_id, $body = null, $is_primary = null, $type_id = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddress';
        $request = $this->restAccountsContactsContactIdAddressesPostRequest($contact_id, $body, $is_primary, $type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdAddressesPost'
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  bool $is_primary Sets a contact address per address type as the primary address. (optional)
     * @param  int $type_id The type ID of the address. Possible values: &lt;ul&gt;&lt;li&gt;Invoice address &#x3D; 1&lt;/li&gt;&lt;li&gt; Delivery address &#x3D; 2&lt;/li&gt;&lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdAddressesPostRequest($contact_id, $body = null, $is_primary = null, $type_id = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdAddressesPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_primary !== null) {
            $queryParams['isPrimary'] = ObjectSerializer::toQueryValue($is_primary);
        }
        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGet
     *
     * List bank accounts
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank[]
     */
    public function restAccountsContactsContactIdBanksGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdBanksGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdBanksGetWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank[]';
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsync
     *
     * List bank accounts
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdBanksGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdBanksGetAsyncWithHttpInfo
     *
     * List bank accounts
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdBanksGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactBank[]';
        $request = $this->restAccountsContactsContactIdBanksGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdBanksGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdBanksGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdBanksGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/banks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGet
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id contact_id (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsContactIdContactEventsGet($contact_id, $page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountsContactsContactIdContactEventsGetWithHttpInfo($contact_id, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdContactEventsGetWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsync
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsync($contact_id, $page = null, $items_per_page = null)
    {
        return $this->restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo($contact_id, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo
     *
     * List contact events by contact ID
     *
     * @param  int $contact_id (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdContactEventsGetAsyncWithHttpInfo($contact_id, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdContactEventsGet'
     *
     * @param  int $contact_id (required)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdContactEventsGetRequest($contact_id, $page = null, $items_per_page = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdContactEventsGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/contact_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdDelete
     *
     * Delete a contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdDelete($contact_id, $check_existing_orders = null)
    {
        $this->restAccountsContactsContactIdDeleteWithHttpInfo($contact_id, $check_existing_orders);
    }

    /**
     * Operation restAccountsContactsContactIdDeleteWithHttpInfo
     *
     * Delete a contact
     *
     * @param  int $contact_id (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdDeleteWithHttpInfo($contact_id, $check_existing_orders = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsync
     *
     * Delete a contact
     *
     * @param  int $contact_id (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsync($contact_id, $check_existing_orders = null)
    {
        return $this->restAccountsContactsContactIdDeleteAsyncWithHttpInfo($contact_id, $check_existing_orders)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact
     *
     * @param  int $contact_id (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdDeleteAsyncWithHttpInfo($contact_id, $check_existing_orders = null)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdDelete'
     *
     * @param  int $contact_id (required)
     * @param  bool $check_existing_orders Flag that checks if the contact is linked to orders. If the contact is linked to orders, CustomerDeleteException is thrown and the contact will not be deleted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdDeleteRequest($contact_id, $check_existing_orders = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($check_existing_orders !== null) {
            $queryParams['checkExistingOrders'] = ObjectSerializer::toQueryValue($check_existing_orders);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdGet
     *
     * Get a contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContact
     */
    public function restAccountsContactsContactIdGet($contact_id, $with = null)
    {
        list($response) = $this->restAccountsContactsContactIdGetWithHttpInfo($contact_id, $with);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdGetWithHttpInfo
     *
     * Get a contact
     *
     * @param  int $contact_id (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdGetWithHttpInfo($contact_id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdGetAsync
     *
     * Get a contact
     *
     * @param  int $contact_id (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsync($contact_id, $with = null)
    {
        return $this->restAccountsContactsContactIdGetAsyncWithHttpInfo($contact_id, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdGetAsyncWithHttpInfo
     *
     * Get a contact
     *
     * @param  int $contact_id (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdGetAsyncWithHttpInfo($contact_id, $with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdGetRequest($contact_id, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdGet'
     *
     * @param  int $contact_id (required)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts. More than one parameter should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdGetRequest($contact_id, $with = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDelete
     *
     * Delete a contact option by the contact ID
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsContactIdOptionsDelete($contact_id)
    {
        $this->restAccountsContactsContactIdOptionsDeleteWithHttpInfo($contact_id);
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteWithHttpInfo
     *
     * Delete a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsDeleteWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsync
     *
     * Delete a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo
     *
     * Delete a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsDeleteAsyncWithHttpInfo($contact_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsContactIdOptionsDeleteRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsDelete'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsDeleteRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGet
     *
     * List contact options by the contact ID
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]
     */
    public function restAccountsContactsContactIdOptionsGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetWithHttpInfo
     *
     * List contact options by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsGetWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsync
     *
     * List contact options by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo
     *
     * List contact options by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPost
     *
     * Create a contact option by the contact ID
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPost($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostWithHttpInfo
     *
     * Create a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPostWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsync
     *
     * Create a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo
     *
     * Create a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPost'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPost'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPut
     *
     * Update a contact option by the contact ID
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]
     */
    public function restAccountsContactsContactIdOptionsPut($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsPutWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutWithHttpInfo
     *
     * Update a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsPutWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsync
     *
     * Update a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo
     *
     * Update a contact option by the contact ID
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsPutAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption[]';
        $request = $this->restAccountsContactsContactIdOptionsPutRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsPut'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsPutRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGet
     *
     * Validate a contact option by a given value
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsContactIdOptionsValidateGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdOptionsValidateGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetWithHttpInfo
     *
     * Validate a contact option by a given value
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdOptionsValidateGetWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsync
     *
     * Validate a contact option by a given value
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo
     *
     * Validate a contact option by a given value
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdOptionsValidateGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdOptionsValidateGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdOptionsValidateGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdOptionsValidateGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdOptionsValidateGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/options/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdPut
     *
     * Update a contact
     *
     * @param  int $contact_id contact_id (required)
     * @param  object $body body (optional)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContact
     */
    public function restAccountsContactsContactIdPut($contact_id, $body = null, $tag_relationships = null)
    {
        list($response) = $this->restAccountsContactsContactIdPutWithHttpInfo($contact_id, $body, $tag_relationships);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdPutWithHttpInfo
     *
     * Update a contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdPutWithHttpInfo($contact_id, $body = null, $tag_relationships = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $body, $tag_relationships);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdPutAsync
     *
     * Update a contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsync($contact_id, $body = null, $tag_relationships = null)
    {
        return $this->restAccountsContactsContactIdPutAsyncWithHttpInfo($contact_id, $body, $tag_relationships)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdPutAsyncWithHttpInfo
     *
     * Update a contact
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdPutAsyncWithHttpInfo($contact_id, $body = null, $tag_relationships = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdPutRequest($contact_id, $body, $tag_relationships);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdPut'
     *
     * @param  int $contact_id (required)
     * @param  object $body (optional)
     * @param  int $tag_relationships When this parameter is used, the current relations between contacts and tags will be deleted and replaced by the given ones. If the parameter is not used, the current relations remain. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdPutRequest($contact_id, $body = null, $tag_relationships = null)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tag_relationships !== null) {
            $queryParams['tagRelationships'] = ObjectSerializer::toQueryValue($tag_relationships);
        }

        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGet
     *
     * Return all contact related data
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContact
     */
    public function restAccountsContactsContactIdRelatedDataGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdRelatedDataGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetWithHttpInfo
     *
     * Return all contact related data
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdRelatedDataGetWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsync
     *
     * Return all contact related data
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo
     *
     * Return all contact related data
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdRelatedDataGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsContactIdRelatedDataGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdRelatedDataGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdRelatedDataGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdRelatedDataGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/related_data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGet
     *
     * get a filestream of vcard from customer
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsContactIdVcardGet($contact_id)
    {
        list($response) = $this->restAccountsContactsContactIdVcardGetWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetWithHttpInfo
     *
     * get a filestream of vcard from customer
     *
     * @param  int $contact_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsContactIdVcardGetWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsync
     *
     * get a filestream of vcard from customer
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsync($contact_id)
    {
        return $this->restAccountsContactsContactIdVcardGetAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsContactIdVcardGetAsyncWithHttpInfo
     *
     * get a filestream of vcard from customer
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsContactIdVcardGetAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsContactIdVcardGetRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsContactIdVcardGet'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsContactIdVcardGetRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restAccountsContactsContactIdVcardGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/{contactId}/vcard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDelete
     *
     * Delete a contact department
     *
     * @param  int $department_id department_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsDepartmentsDepartmentIdDelete($department_id)
    {
        $this->restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo($department_id);
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo
     *
     * Delete a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteWithHttpInfo($department_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsync
     *
     * Delete a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsync($department_id)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo($department_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdDeleteAsyncWithHttpInfo($department_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdDelete'
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdDeleteRequest($department_id)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGet
     *
     * Get a contact department
     *
     * @param  int $department_id department_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdGet($department_id)
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo($department_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo
     *
     * Get a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetWithHttpInfo($department_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsync
     *
     * Get a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsync($department_id)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo($department_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo
     *
     * Get a contact department
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdGetAsyncWithHttpInfo($department_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdGet'
     *
     * @param  int $department_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdGetRequest($department_id)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPut
     *
     * Update a contact department
     *
     * @param  int $department_id department_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment
     */
    public function restAccountsContactsDepartmentsDepartmentIdPut($department_id, $body = null)
    {
        list($response) = $this->restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo($department_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo
     *
     * Update a contact department
     *
     * @param  int $department_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutWithHttpInfo($department_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsync
     *
     * Update a contact department
     *
     * @param  int $department_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsync($department_id, $body = null)
    {
        return $this->restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo($department_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo
     *
     * Update a contact department
     *
     * @param  int $department_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsDepartmentIdPutAsyncWithHttpInfo($department_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsDepartmentIdPut'
     *
     * @param  int $department_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsDepartmentIdPutRequest($department_id, $body = null)
    {
        // verify the required parameter 'department_id' is set
        if ($department_id === null || (is_array($department_id) && count($department_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department_id when calling restAccountsContactsDepartmentsDepartmentIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/departments/{departmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($department_id !== null) {
            $resourcePath = str_replace(
                '{' . 'departmentId' . '}',
                ObjectSerializer::toPathValue($department_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsGet
     *
     * List contact departments
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment[]
     */
    public function restAccountsContactsDepartmentsGet()
    {
        list($response) = $this->restAccountsContactsDepartmentsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsGetWithHttpInfo
     *
     * List contact departments
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment[]';
        $request = $this->restAccountsContactsDepartmentsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsync
     *
     * List contact departments
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsync()
    {
        return $this->restAccountsContactsDepartmentsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsGetAsyncWithHttpInfo
     *
     * List contact departments
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment[]';
        $request = $this->restAccountsContactsDepartmentsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsDepartmentsPost
     *
     * Create a contact department
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment
     */
    public function restAccountsContactsDepartmentsPost($body = null)
    {
        list($response) = $this->restAccountsContactsDepartmentsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsDepartmentsPostWithHttpInfo
     *
     * Create a contact department
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsDepartmentsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsync
     *
     * Create a contact department
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsync($body = null)
    {
        return $this->restAccountsContactsDepartmentsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsDepartmentsPostAsyncWithHttpInfo
     *
     * Create a contact department
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsDepartmentsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactDepartment';
        $request = $this->restAccountsContactsDepartmentsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsDepartmentsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsDepartmentsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGet
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postal code (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#x27;true&#x27; and &#x27;false&#x27;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or id. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the id provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the id provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsContactsGet($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        list($response) = $this->restAccountsContactsGetWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);
        return $response;
    }

    /**
     * Operation restAccountsContactsGetWithHttpInfo
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postal code (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#x27;true&#x27; and &#x27;false&#x27;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or id. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the id provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the id provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGetWithHttpInfo($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGetAsync
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postal code (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#x27;true&#x27; and &#x27;false&#x27;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or id. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the id provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the id provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGetAsync($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        return $this->restAccountsContactsGetAsyncWithHttpInfo($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGetAsyncWithHttpInfo
     *
     * List contacts
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postal code (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#x27;true&#x27; and &#x27;false&#x27;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or id. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the id provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the id provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGetAsyncWithHttpInfo($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsContactsGetRequest($full_text, $contact_email, $email, $postal_code, $plenty_id, $external_id, $number, $type_id, $rating, $created_at_before, $created_at_after, $updated_at_before, $updated_at_after, $with, $page, $items_per_page, $newsletter_allowance_after, $newsletter_allowance_before, $newsletter_allowance, $contact_id, $contact_address, $country_id, $user_id, $referrer_id, $name, $name_or_id, $town, $private_phone, $billing_address_id, $delivery_address_id, $tag_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGet'
     *
     * @param  string $full_text Filter for a fulltext search (optional)
     * @param  string $contact_email Filter that restricts the search result to contacts resembling to the given email address (optional)
     * @param  string $email Filter that restricts the search result to contacts with a specific email address (optional)
     * @param  string $postal_code Filter that restricts the search result to contacts with a specific postal code (optional)
     * @param  int $plenty_id Filter that restricts the search result to contacts with a specific plentyId (optional)
     * @param  int $external_id Filter that restricts the search result to contacts with a specific externalId (optional)
     * @param  int $number Filter that restricts the search result to contacts with a specific number (optional)
     * @param  int $type_id Filter that restricts the search result to contacts with a specific contact type (optional)
     * @param  int $rating Filter that restricts the search result to contacts with a specific rating (optional)
     * @param  string $created_at_before Filter that restricts the search result to contacts that were created before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $created_at_after Filter that restricts the search result to contacts that were created after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_before Filter that restricts the search result to contacts that were updated before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $updated_at_after Filter that restricts the search result to contacts that were updated after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $with Includes the specified contact information in the results. The following parameters are available: addresses, accounts, options, orderSummary, primaryBillingAddress. More than one parameter should be separated by commas. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     * @param  string $newsletter_allowance_after Filter that restricts the search result to contacts who registered for the newsletter after a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance_before Filter that restricts the search result to contacts who registered for the newsletter before a specific date. Possible formats: yyyy-mm-dd, mm/dd/yyyy. (optional)
     * @param  string $newsletter_allowance Filter that restricts the search result to contacts who registered for the newsletter. Possible values: &#x27;true&#x27; and &#x27;false&#x27;. True: newsletter registration was successful. False: newsletter registration was not successful. (optional)
     * @param  int $contact_id Filter that restricts the search result to a specific contact (optional)
     * @param  string $contact_address Filter that restricts the search result to contacts with a specific address (optional)
     * @param  string $country_id Filter that restricts the search result to contacts with a specific country (optional)
     * @param  string $user_id Filter that restricts the search result to contacts with a specific user (optional)
     * @param  string $referrer_id Filter that restricts the search result to contacts with a specific referrer (optional)
     * @param  string $name Filter that restricts the search result to contacts with a specific name (optional)
     * @param  string $name_or_id Filter that restricts the search result to contacts with a specific name or id. (optional)
     * @param  string $town Filter that restricts the search result to contacts with a specific town (optional)
     * @param  string $private_phone Filter that restricts the search result to contacts with a private phone number (optional)
     * @param  string $billing_address_id Filter that restricts the search result to contacts with a billing address with the id provided (optional)
     * @param  string $delivery_address_id Filter that restricts the search result to contacts with a delivery address with the id provided (optional)
     * @param  int $tag_ids Filter restricts the list of results to contacts with the specified tagIds. More than one ID should be separated by commas. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGetRequest($full_text = null, $contact_email = null, $email = null, $postal_code = null, $plenty_id = null, $external_id = null, $number = null, $type_id = null, $rating = null, $created_at_before = null, $created_at_after = null, $updated_at_before = null, $updated_at_after = null, $with = null, $page = null, $items_per_page = null, $newsletter_allowance_after = null, $newsletter_allowance_before = null, $newsletter_allowance = null, $contact_id = null, $contact_address = null, $country_id = null, $user_id = null, $referrer_id = null, $name = null, $name_or_id = null, $town = null, $private_phone = null, $billing_address_id = null, $delivery_address_id = null, $tag_ids = null)
    {

        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($full_text !== null) {
            $queryParams['fullText'] = ObjectSerializer::toQueryValue($full_text);
        }
        // query params
        if ($contact_email !== null) {
            $queryParams['contactEmail'] = ObjectSerializer::toQueryValue($contact_email);
        }
        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($postal_code !== null) {
            $queryParams['postalCode'] = ObjectSerializer::toQueryValue($postal_code);
        }
        // query params
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = ObjectSerializer::toQueryValue($plenty_id);
        }
        // query params
        if ($external_id !== null) {
            $queryParams['externalId'] = ObjectSerializer::toQueryValue($external_id);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($type_id !== null) {
            $queryParams['typeId'] = ObjectSerializer::toQueryValue($type_id);
        }
        // query params
        if ($rating !== null) {
            $queryParams['rating'] = ObjectSerializer::toQueryValue($rating);
        }
        // query params
        if ($created_at_before !== null) {
            $queryParams['createdAtBefore'] = ObjectSerializer::toQueryValue($created_at_before);
        }
        // query params
        if ($created_at_after !== null) {
            $queryParams['createdAtAfter'] = ObjectSerializer::toQueryValue($created_at_after);
        }
        // query params
        if ($updated_at_before !== null) {
            $queryParams['updatedAtBefore'] = ObjectSerializer::toQueryValue($updated_at_before);
        }
        // query params
        if ($updated_at_after !== null) {
            $queryParams['updatedAtAfter'] = ObjectSerializer::toQueryValue($updated_at_after);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($newsletter_allowance_after !== null) {
            $queryParams['newsletterAllowanceAfter'] = ObjectSerializer::toQueryValue($newsletter_allowance_after);
        }
        // query params
        if ($newsletter_allowance_before !== null) {
            $queryParams['newsletterAllowanceBefore'] = ObjectSerializer::toQueryValue($newsletter_allowance_before);
        }
        // query params
        if ($newsletter_allowance !== null) {
            $queryParams['newsletterAllowance'] = ObjectSerializer::toQueryValue($newsletter_allowance);
        }
        // query params
        if ($contact_id !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($contact_address !== null) {
            $queryParams['contactAddress'] = ObjectSerializer::toQueryValue($contact_address);
        }
        // query params
        if ($country_id !== null) {
            $queryParams['countryId'] = ObjectSerializer::toQueryValue($country_id);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }
        // query params
        if ($referrer_id !== null) {
            $queryParams['referrerId'] = ObjectSerializer::toQueryValue($referrer_id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($name_or_id !== null) {
            $queryParams['nameOrId'] = ObjectSerializer::toQueryValue($name_or_id);
        }
        // query params
        if ($town !== null) {
            $queryParams['town'] = ObjectSerializer::toQueryValue($town);
        }
        // query params
        if ($private_phone !== null) {
            $queryParams['privatePhone'] = ObjectSerializer::toQueryValue($private_phone);
        }
        // query params
        if ($billing_address_id !== null) {
            $queryParams['billingAddressId'] = ObjectSerializer::toQueryValue($billing_address_id);
        }
        // query params
        if ($delivery_address_id !== null) {
            $queryParams['deliveryAddressId'] = ObjectSerializer::toQueryValue($delivery_address_id);
        }
        // query params
        if ($tag_ids !== null) {
            $queryParams['tagIds'] = ObjectSerializer::toQueryValue($tag_ids);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGet
     *
     * List all group function related data
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsGroupFunctionsGet()
    {
        list($response) = $this->restAccountsContactsGroupFunctionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetWithHttpInfo
     *
     * List all group function related data
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsGroupFunctionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsync
     *
     * List all group function related data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsync()
    {
        return $this->restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo
     *
     * List all group function related data
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsGroupFunctionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGroupFunctionsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPost
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyDataSimpleRestResponse
     */
    public function restAccountsContactsGroupFunctionsPost($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        list($response) = $this->restAccountsContactsGroupFunctionsPostWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template);
        return $response;
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsGroupFunctionsPostWithHttpInfo($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsync
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsync($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        return $this->restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo($contact_list, $email_template, $newsletter, $address_label_template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo
     *
     * Apply selected group function options for given contact IDs
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsGroupFunctionsPostAsyncWithHttpInfo($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyDataSimpleRestResponse';
        $request = $this->restAccountsContactsGroupFunctionsPostRequest($contact_list, $email_template, $newsletter, $address_label_template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsGroupFunctionsPost'
     *
     * @param  int $contact_list A list of contact IDs (optional)
     * @param  int $email_template An email template ID (optional)
     * @param  int $newsletter A newsletter folder ID (optional)
     * @param  int $address_label_template An address label template ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsGroupFunctionsPostRequest($contact_list = null, $email_template = null, $newsletter = null, $address_label_template = null)
    {

        $resourcePath = '/rest/accounts/contacts/group_functions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contact_list !== null) {
            $queryParams['contactList'] = ObjectSerializer::toQueryValue($contact_list);
        }
        // query params
        if ($email_template !== null) {
            $queryParams['emailTemplate'] = ObjectSerializer::toQueryValue($email_template);
        }
        // query params
        if ($newsletter !== null) {
            $queryParams['newsletter'] = ObjectSerializer::toQueryValue($newsletter);
        }
        // query params
        if ($address_label_template !== null) {
            $queryParams['addressLabelTemplate'] = ObjectSerializer::toQueryValue($address_label_template);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGet
     *
     * List contact option sub-types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType[]
     */
    public function restAccountsContactsOptionSubTypesGet()
    {
        list($response) = $this->restAccountsContactsOptionSubTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetWithHttpInfo
     *
     * List contact option sub-types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType[]';
        $request = $this->restAccountsContactsOptionSubTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsync
     *
     * List contact option sub-types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsync()
    {
        return $this->restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo
     *
     * List contact option sub-types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType[]';
        $request = $this->restAccountsContactsOptionSubTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDelete
     *
     * Delete a contact option sub-type
     *
     * @param  int $option_sub_type_id option_sub_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDelete($option_sub_type_id)
    {
        $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo($option_sub_type_id);
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo
     *
     * Delete a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteWithHttpInfo($option_sub_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync
     *
     * Delete a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsync($option_sub_type_id)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo($option_sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteAsyncWithHttpInfo($option_sub_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdDeleteRequest($option_sub_type_id)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGet
     *
     * Get a contact option sub-type
     *
     * @param  int $option_sub_type_id option_sub_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGet($option_sub_type_id)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo($option_sub_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo
     *
     * Get a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetWithHttpInfo($option_sub_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync
     *
     * Get a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsync($option_sub_type_id)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo($option_sub_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo
     *
     * Get a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdGetAsyncWithHttpInfo($option_sub_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
     *
     * @param  int $option_sub_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdGetRequest($option_sub_type_id)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPut
     *
     * Update a contact option sub-type
     *
     * @param  int $option_sub_type_id option_sub_type_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPut($option_sub_type_id, $body = null)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo($option_sub_type_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo
     *
     * Update a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutWithHttpInfo($option_sub_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync
     *
     * Update a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsync($option_sub_type_id, $body = null)
    {
        return $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo($option_sub_type_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo
     *
     * Update a contact option sub-type
     *
     * @param  int $option_sub_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesOptionSubTypeIdPutAsyncWithHttpInfo($option_sub_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
     *
     * @param  int $option_sub_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesOptionSubTypeIdPutRequest($option_sub_type_id, $body = null)
    {
        // verify the required parameter 'option_sub_type_id' is set
        if ($option_sub_type_id === null || (is_array($option_sub_type_id) && count($option_sub_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_sub_type_id when calling restAccountsContactsOptionSubTypesOptionSubTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_sub_types/{optionSubTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_sub_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionSubTypeId' . '}',
                ObjectSerializer::toPathValue($option_sub_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPost
     *
     * Create a contact option sub-type
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType
     */
    public function restAccountsContactsOptionSubTypesPost($body = null)
    {
        list($response) = $this->restAccountsContactsOptionSubTypesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostWithHttpInfo
     *
     * Create a contact option sub-type
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionSubTypesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsync
     *
     * Create a contact option sub-type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsync($body = null)
    {
        return $this->restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo
     *
     * Create a contact option sub-type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionSubTypesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionSubType';
        $request = $this->restAccountsContactsOptionSubTypesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionSubTypesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionSubTypesPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_sub_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesGet
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#x27;subTypes&#x27; is set. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType[]
     */
    public function restAccountsContactsOptionTypesGet($with = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesGetWithHttpInfo($with);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesGetWithHttpInfo
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#x27;subTypes&#x27; is set. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesGetWithHttpInfo($with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType[]';
        $request = $this->restAccountsContactsOptionTypesGetRequest($with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsync
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#x27;subTypes&#x27; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsync($with = null)
    {
        return $this->restAccountsContactsOptionTypesGetAsyncWithHttpInfo($with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesGetAsyncWithHttpInfo
     *
     * List contact option types
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#x27;subTypes&#x27; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesGetAsyncWithHttpInfo($with = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType[]';
        $request = $this->restAccountsContactsOptionTypesGetRequest($with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesGet'
     *
     * @param  string $with Lists possible option sub-types for each listed option if the parameter &#x27;subTypes&#x27; is set. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesGetRequest($with = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDelete
     *
     * Delete a contact option type
     *
     * @param  int $option_type_id option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDelete($option_type_id)
    {
        $this->restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id);
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo
     *
     * Delete a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsync
     *
     * Delete a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsync($option_type_id)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdDeleteAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdDelete'
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdDeleteRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGet
     *
     * Get a contact option type
     *
     * @param  int $option_type_id option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGet($option_type_id)
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo
     *
     * Get a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetWithHttpInfo($option_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsync
     *
     * Get a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsync($option_type_id)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo
     *
     * Get a contact option type
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdGetAsyncWithHttpInfo($option_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdGet'
     *
     * @param  int $option_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdGetRequest($option_type_id)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPut
     *
     * Update a contact option type
     *
     * @param  int $option_type_id option_type_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPut($option_type_id, $body = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo
     *
     * Update a contact option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutWithHttpInfo($option_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsync
     *
     * Update a contact option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsync($option_type_id, $body = null)
    {
        return $this->restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo
     *
     * Update a contact option type
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesOptionTypeIdPutAsyncWithHttpInfo($option_type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesOptionTypeIdPut'
     *
     * @param  int $option_type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesOptionTypeIdPutRequest($option_type_id, $body = null)
    {
        // verify the required parameter 'option_type_id' is set
        if ($option_type_id === null || (is_array($option_type_id) && count($option_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_type_id when calling restAccountsContactsOptionTypesOptionTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/option_types/{optionTypeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionTypeId' . '}',
                ObjectSerializer::toPathValue($option_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionTypesPost
     *
     * Create a contact option type
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType
     */
    public function restAccountsContactsOptionTypesPost($body = null)
    {
        list($response) = $this->restAccountsContactsOptionTypesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionTypesPostWithHttpInfo
     *
     * Create a contact option type
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionTypesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsync
     *
     * Create a contact option type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsync($body = null)
    {
        return $this->restAccountsContactsOptionTypesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionTypesPostAsyncWithHttpInfo
     *
     * Create a contact option type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionTypesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOptionType';
        $request = $this->restAccountsContactsOptionTypesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionTypesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionTypesPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/option_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDelete
     *
     * Delete a contact option by the option ID
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsOptionsOptionIdDelete($option_id)
    {
        $this->restAccountsContactsOptionsOptionIdDeleteWithHttpInfo($option_id);
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteWithHttpInfo
     *
     * Delete a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdDeleteWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsync
     *
     * Delete a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdDeleteAsyncWithHttpInfo($option_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsOptionsOptionIdDeleteRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdDelete'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdDeleteRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGet
     *
     * Get a contact option by the option ID
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption
     */
    public function restAccountsContactsOptionsOptionIdGet($option_id)
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdGetWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetWithHttpInfo
     *
     * Get a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdGetWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsync
     *
     * Get a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo
     *
     * Get a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdGetAsyncWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdGetRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdGet'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdGetRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPut
     *
     * Update a contact option by the option ID
     *
     * @param  int $option_id option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption
     */
    public function restAccountsContactsOptionsOptionIdPut($option_id)
    {
        list($response) = $this->restAccountsContactsOptionsOptionIdPutWithHttpInfo($option_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutWithHttpInfo
     *
     * Update a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsOptionsOptionIdPutWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsync
     *
     * Update a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsync($option_id)
    {
        return $this->restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo($option_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo
     *
     * Update a contact option by the option ID
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsOptionsOptionIdPutAsyncWithHttpInfo($option_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactOption';
        $request = $this->restAccountsContactsOptionsOptionIdPutRequest($option_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsOptionsOptionIdPut'
     *
     * @param  int $option_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsOptionsOptionIdPutRequest($option_id)
    {
        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling restAccountsContactsOptionsOptionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/options/{optionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($option_id !== null) {
            $resourcePath = str_replace(
                '{' . 'optionId' . '}',
                ObjectSerializer::toPathValue($option_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsGet
     *
     * List contact positions
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition[]
     */
    public function restAccountsContactsPositionsGet()
    {
        list($response) = $this->restAccountsContactsPositionsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsGetWithHttpInfo
     *
     * List contact positions
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition[]';
        $request = $this->restAccountsContactsPositionsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsGetAsync
     *
     * List contact positions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsync()
    {
        return $this->restAccountsContactsPositionsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsGetAsyncWithHttpInfo
     *
     * List contact positions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition[]';
        $request = $this->restAccountsContactsPositionsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDelete
     *
     * Delete a contact position
     *
     * @param  int $position_id position_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsPositionsPositionIdDelete($position_id)
    {
        $this->restAccountsContactsPositionsPositionIdDeleteWithHttpInfo($position_id);
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteWithHttpInfo
     *
     * Delete a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdDeleteWithHttpInfo($position_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsync
     *
     * Delete a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsync($position_id)
    {
        return $this->restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo($position_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdDeleteAsyncWithHttpInfo($position_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsPositionsPositionIdDeleteRequest($position_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdDelete'
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdDeleteRequest($position_id)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGet
     *
     * Get a contact position
     *
     * @param  int $position_id position_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition
     */
    public function restAccountsContactsPositionsPositionIdGet($position_id)
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdGetWithHttpInfo($position_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetWithHttpInfo
     *
     * Get a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdGetWithHttpInfo($position_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsync
     *
     * Get a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsync($position_id)
    {
        return $this->restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo($position_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo
     *
     * Get a contact position
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdGetAsyncWithHttpInfo($position_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdGetRequest($position_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdGet'
     *
     * @param  int $position_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdGetRequest($position_id)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPut
     *
     * Update a contact position
     *
     * @param  int $position_id position_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition
     */
    public function restAccountsContactsPositionsPositionIdPut($position_id, $body = null)
    {
        list($response) = $this->restAccountsContactsPositionsPositionIdPutWithHttpInfo($position_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutWithHttpInfo
     *
     * Update a contact position
     *
     * @param  int $position_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPositionIdPutWithHttpInfo($position_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsync
     *
     * Update a contact position
     *
     * @param  int $position_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsync($position_id, $body = null)
    {
        return $this->restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo($position_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo
     *
     * Update a contact position
     *
     * @param  int $position_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPositionIdPutAsyncWithHttpInfo($position_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPositionIdPutRequest($position_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPositionIdPut'
     *
     * @param  int $position_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPositionIdPutRequest($position_id, $body = null)
    {
        // verify the required parameter 'position_id' is set
        if ($position_id === null || (is_array($position_id) && count($position_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $position_id when calling restAccountsContactsPositionsPositionIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/positions/{positionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($position_id !== null) {
            $resourcePath = str_replace(
                '{' . 'positionId' . '}',
                ObjectSerializer::toPathValue($position_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPositionsPost
     *
     * Create a contact position
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition
     */
    public function restAccountsContactsPositionsPost($body = null)
    {
        list($response) = $this->restAccountsContactsPositionsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsPositionsPostWithHttpInfo
     *
     * Create a contact position
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPositionsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPositionsPostAsync
     *
     * Create a contact position
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsync($body = null)
    {
        return $this->restAccountsContactsPositionsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPositionsPostAsyncWithHttpInfo
     *
     * Create a contact position
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPositionsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactPosition';
        $request = $this->restAccountsContactsPositionsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPositionsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPositionsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/positions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsPost
     *
     * Create a contact
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContact
     */
    public function restAccountsContactsPost($body = null)
    {
        list($response) = $this->restAccountsContactsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsPostWithHttpInfo
     *
     * Create a contact
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContact, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsPostAsync
     *
     * Create a contact
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPostAsync($body = null)
    {
        return $this->restAccountsContactsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsPostAsyncWithHttpInfo
     *
     * Create a contact
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContact';
        $request = $this->restAccountsContactsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesGet
     *
     * List contact types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType[]
     */
    public function restAccountsContactsTypesGet()
    {
        list($response) = $this->restAccountsContactsTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesGetWithHttpInfo
     *
     * List contact types
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesGetWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType[]';
        $request = $this->restAccountsContactsTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesGetAsync
     *
     * List contact types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesGetAsync()
    {
        return $this->restAccountsContactsTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesGetAsyncWithHttpInfo
     *
     * List contact types
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType[]';
        $request = $this->restAccountsContactsTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesGetRequest()
    {

        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesPost
     *
     * Create a contact type
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType
     */
    public function restAccountsContactsTypesPost($body = null)
    {
        list($response) = $this->restAccountsContactsTypesPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesPostWithHttpInfo
     *
     * Create a contact type
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesPostAsync
     *
     * Create a contact type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesPostAsync($body = null)
    {
        return $this->restAccountsContactsTypesPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesPostAsyncWithHttpInfo
     *
     * Create a contact type
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts/contacts/types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDelete
     *
     * Delete a contact type
     *
     * @param  int $type_id type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountsContactsTypesTypeIdDelete($type_id)
    {
        $this->restAccountsContactsTypesTypeIdDeleteWithHttpInfo($type_id);
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteWithHttpInfo
     *
     * Delete a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdDeleteWithHttpInfo($type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsync
     *
     * Delete a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsync($type_id)
    {
        return $this->restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo
     *
     * Delete a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdDeleteAsyncWithHttpInfo($type_id)
    {
        $returnType = '';
        $request = $this->restAccountsContactsTypesTypeIdDeleteRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdDelete'
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdDeleteRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdDelete'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGet
     *
     * Get a contact type
     *
     * @param  int $type_id type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType
     */
    public function restAccountsContactsTypesTypeIdGet($type_id)
    {
        list($response) = $this->restAccountsContactsTypesTypeIdGetWithHttpInfo($type_id);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetWithHttpInfo
     *
     * Get a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdGetWithHttpInfo($type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsync
     *
     * Get a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsync($type_id)
    {
        return $this->restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo($type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo
     *
     * Get a contact type
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdGetAsyncWithHttpInfo($type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesTypeIdGetRequest($type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdGet'
     *
     * @param  int $type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdGetRequest($type_id)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdGet'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPut
     *
     * Update a contact type
     *
     * @param  int $type_id type_id (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType
     */
    public function restAccountsContactsTypesTypeIdPut($type_id, $body = null)
    {
        list($response) = $this->restAccountsContactsTypesTypeIdPutWithHttpInfo($type_id, $body);
        return $response;
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutWithHttpInfo
     *
     * Update a contact type
     *
     * @param  int $type_id (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountContactModelsContactType, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsContactsTypesTypeIdPutWithHttpInfo($type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsync
     *
     * Update a contact type
     *
     * @param  int $type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsync($type_id, $body = null)
    {
        return $this->restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo($type_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo
     *
     * Update a contact type
     *
     * @param  int $type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsContactsTypesTypeIdPutAsyncWithHttpInfo($type_id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountContactModelsContactType';
        $request = $this->restAccountsContactsTypesTypeIdPutRequest($type_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsContactsTypesTypeIdPut'
     *
     * @param  int $type_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsContactsTypesTypeIdPutRequest($type_id, $body = null)
    {
        // verify the required parameter 'type_id' is set
        if ($type_id === null || (is_array($type_id) && count($type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type_id when calling restAccountsContactsTypesTypeIdPut'
            );
        }

        $resourcePath = '/rest/accounts/contacts/types/{typeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'typeId' . '}',
                ObjectSerializer::toPathValue($type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsGet
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                     &lt;br&gt; Usage: &lt;ul&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;like:expamle&#x27;&lt;/li&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;eq:example&#x27; (&#x3D;)&lt;/li&gt;                                     &lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountsGet($updated_at = null, $created_at = null, $company_name = null)
    {
        list($response) = $this->restAccountsGetWithHttpInfo($updated_at, $created_at, $company_name);
        return $response;
    }

    /**
     * Operation restAccountsGetWithHttpInfo
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                     &lt;br&gt; Usage: &lt;ul&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;like:expamle&#x27;&lt;/li&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;eq:example&#x27; (&#x3D;)&lt;/li&gt;                                     &lt;/ul&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsGetWithHttpInfo($updated_at = null, $created_at = null, $company_name = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsGetAsync
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                     &lt;br&gt; Usage: &lt;ul&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;like:expamle&#x27;&lt;/li&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;eq:example&#x27; (&#x3D;)&lt;/li&gt;                                     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsGetAsync($updated_at = null, $created_at = null, $company_name = null)
    {
        return $this->restAccountsGetAsyncWithHttpInfo($updated_at, $created_at, $company_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsGetAsyncWithHttpInfo
     *
     * List accounts
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                     &lt;br&gt; Usage: &lt;ul&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;like:expamle&#x27;&lt;/li&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;eq:example&#x27; (&#x3D;)&lt;/li&gt;                                     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsGetAsyncWithHttpInfo($updated_at = null, $created_at = null, $company_name = null)
    {
        $returnType = 'object';
        $request = $this->restAccountsGetRequest($updated_at, $created_at, $company_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsGet'
     *
     * @param  string $updated_at Filter that restricts the search result to accounts that were updated according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;updatedAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $created_at Filter that restricts the search result to accounts that were created according to given filters.                                    &lt;br&gt; Usage: &lt;ul&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;between:yyyy-mm-dd,yyyy-mm-dd&#x27;&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;eq:yyyy-mm-dd&#x27; (&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gt:yyyy-mm-dd&#x27; (&gt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;gte:yyyy-mm-dd&#x27; (&gt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lt:yyyy-mm-dd&#x27; (&lt;)&lt;/li&gt;                                    &lt;li&gt;&#x27;createdAt&#x3D;lte:yyyy-mm-dd&#x27; (&lt;&#x3D;)&lt;/li&gt;                                    &lt;li&gt;Dates can also include the time. Example: 2017-03-08 13:24:17&lt;/li&gt;                                    &lt;li&gt;Without including the time we will use 00:00:00 as default. Example: 2017-03-08 00:00:00&lt;/li&gt;           &lt;/ul&gt; (optional)
     * @param  string $company_name Filter that restricts the search result to accounts that have a company name according to given filters.                                     &lt;br&gt; Usage: &lt;ul&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;like:expamle&#x27;&lt;/li&gt;                                     &lt;li&gt;&#x27;companyName&#x3D;eq:example&#x27; (&#x3D;)&lt;/li&gt;                                     &lt;/ul&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsGetRequest($updated_at = null, $created_at = null, $company_name = null)
    {

        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = ObjectSerializer::toQueryValue($updated_at);
        }
        // query params
        if ($created_at !== null) {
            $queryParams['createdAt'] = ObjectSerializer::toQueryValue($created_at);
        }
        // query params
        if ($company_name !== null) {
            $queryParams['companyName'] = ObjectSerializer::toQueryValue($company_name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountsPost
     *
     * Create an account
     *
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountModelsAccount
     */
    public function restAccountsPost($body = null)
    {
        list($response) = $this->restAccountsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountsPostWithHttpInfo
     *
     * Create an account
     *
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountModelsAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountsPostWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountModelsAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountsPostAsync
     *
     * Create an account
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsPostAsync($body = null)
    {
        return $this->restAccountsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountsPostAsyncWithHttpInfo
     *
     * Create an account
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountModelsAccount';
        $request = $this->restAccountsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersAddressesPost
     *
     * Create an address for existing order
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation
     */
    public function restOrdersAddressesPost()
    {
        list($response) = $this->restOrdersAddressesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restOrdersAddressesPostWithHttpInfo
     *
     * Create an address for existing order
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersAddressesPostWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation';
        $request = $this->restOrdersAddressesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersAddressesPostAsync
     *
     * Create an address for existing order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersAddressesPostAsync()
    {
        return $this->restOrdersAddressesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersAddressesPostAsyncWithHttpInfo
     *
     * Create an address for existing order
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersAddressesPostAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation';
        $request = $this->restOrdersAddressesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersAddressesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersAddressesPostRequest()
    {

        $resourcePath = '/rest/orders/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdAddressesRelationTypeIdGet
     *
     * List order addresses
     *
     * @param  int $order_id order_id (required)
     * @param  int $relation_type_id relation_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation
     */
    public function restOrdersOrderIdAddressesRelationTypeIdGet($order_id, $relation_type_id)
    {
        list($response) = $this->restOrdersOrderIdAddressesRelationTypeIdGetWithHttpInfo($order_id, $relation_type_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdAddressesRelationTypeIdGetWithHttpInfo
     *
     * List order addresses
     *
     * @param  int $order_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdAddressesRelationTypeIdGetWithHttpInfo($order_id, $relation_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation';
        $request = $this->restOrdersOrderIdAddressesRelationTypeIdGetRequest($order_id, $relation_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdAddressesRelationTypeIdGetAsync
     *
     * List order addresses
     *
     * @param  int $order_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdAddressesRelationTypeIdGetAsync($order_id, $relation_type_id)
    {
        return $this->restOrdersOrderIdAddressesRelationTypeIdGetAsyncWithHttpInfo($order_id, $relation_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdAddressesRelationTypeIdGetAsyncWithHttpInfo
     *
     * List order addresses
     *
     * @param  int $order_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdAddressesRelationTypeIdGetAsyncWithHttpInfo($order_id, $relation_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressOrderRelation';
        $request = $this->restOrdersOrderIdAddressesRelationTypeIdGetRequest($order_id, $relation_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdAddressesRelationTypeIdGet'
     *
     * @param  int $order_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdAddressesRelationTypeIdGetRequest($order_id, $relation_type_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdAddressesRelationTypeIdGet'
            );
        }
        // verify the required parameter 'relation_type_id' is set
        if ($relation_type_id === null || (is_array($relation_type_id) && count($relation_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_type_id when calling restOrdersOrderIdAddressesRelationTypeIdGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/addresses/{relationTypeId?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($relation_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationTypeId?' . '}',
                ObjectSerializer::toPathValue($relation_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPost
     *
     * Create an address for existing warehouse
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation
     */
    public function restStockmanagementWarehousesAddressesPost()
    {
        list($response) = $this->restStockmanagementWarehousesAddressesPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostWithHttpInfo
     *
     * Create an address for existing warehouse
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStockmanagementWarehousesAddressesPostWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesAddressesPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsync
     *
     * Create an address for existing warehouse
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsync()
    {
        return $this->restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo
     *
     * Create an address for existing warehouse
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesAddressesPostAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesAddressesPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStockmanagementWarehousesAddressesPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restStockmanagementWarehousesAddressesPostRequest()
    {

        $resourcePath = '/rest/stockmanagement/warehouses/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGet
     *
     * List warehouse addresses
     *
     * @param  int $warehouse_id warehouse_id (required)
     * @param  int $relation_type_id relation_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation
     */
    public function restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGet($warehouse_id, $relation_type_id)
    {
        list($response) = $this->restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetWithHttpInfo($warehouse_id, $relation_type_id);
        return $response;
    }

    /**
     * Operation restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetWithHttpInfo
     *
     * List warehouse addresses
     *
     * @param  int $warehouse_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetWithHttpInfo($warehouse_id, $relation_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetRequest($warehouse_id, $relation_type_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetAsync
     *
     * List warehouse addresses
     *
     * @param  int $warehouse_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetAsync($warehouse_id, $relation_type_id)
    {
        return $this->restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetAsyncWithHttpInfo($warehouse_id, $relation_type_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetAsyncWithHttpInfo
     *
     * List warehouse addresses
     *
     * @param  int $warehouse_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetAsyncWithHttpInfo($warehouse_id, $relation_type_id)
    {
        $returnType = '\Swagger\Client\Model\PlentyModulesAccountAddressModelsAddressWarehouseRelation';
        $request = $this->restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetRequest($warehouse_id, $relation_type_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGet'
     *
     * @param  int $warehouse_id (required)
     * @param  int $relation_type_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGetRequest($warehouse_id, $relation_type_id)
    {
        // verify the required parameter 'warehouse_id' is set
        if ($warehouse_id === null || (is_array($warehouse_id) && count($warehouse_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $warehouse_id when calling restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGet'
            );
        }
        // verify the required parameter 'relation_type_id' is set
        if ($relation_type_id === null || (is_array($relation_type_id) && count($relation_type_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relation_type_id when calling restStockmanagementWarehousesWarehouseIdAddressesRelationTypeIdGet'
            );
        }

        $resourcePath = '/rest/stockmanagement/warehouses/{warehouseId}/addresses/{relationTypeId?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($warehouse_id !== null) {
            $resourcePath = str_replace(
                '{' . 'warehouseId' . '}',
                ObjectSerializer::toPathValue($warehouse_id),
                $resourcePath
            );
        }
        // path params
        if ($relation_type_id !== null) {
            $resourcePath = str_replace(
                '{' . 'relationTypeId?' . '}',
                ObjectSerializer::toPathValue($relation_type_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
