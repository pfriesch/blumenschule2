<?php
/**
 * AccountingApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;

/**
 * AccountingApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGet
     *
     * Get all unique posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsExistingAccountsGet()
    {
        list($response) = $this->restAccountingLocationsExistingAccountsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetWithHttpInfo
     *
     * Get all unique posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsExistingAccountsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsExistingAccountsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsync
     *
     * Get all unique posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsExistingAccountsGetAsync()
    {
        return $this->restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo
     *
     * Get all unique posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsExistingAccountsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsExistingAccountsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsExistingAccountsGetRequest()
    {

        $resourcePath = '/rest/accounting/locations/existing_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet($location_id, $country_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo($location_id, $country_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo($location_id, $country_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration';
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync($location_id, $country_id)
    {
        return $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo($location_id, $country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo($location_id, $country_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration';
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  int $country_id The ID of the country. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/countries/{countryId}/revenue_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGet
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGet
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGet($location_id, $mode)
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo($location_id, $mode);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo($location_id, $mode)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsync
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsync($location_id, $mode)
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo($location_id, $mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo($location_id, $mode)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountsModeGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_accounts/{mode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($mode !== null) {
            $resourcePath = str_replace(
                '{' . 'mode' . '}',
                ObjectSerializer::toPathValue($mode),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDelete
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountingLocationsLocationIdDelete($location_id)
    {
        $this->restAccountingLocationsLocationIdDeleteWithHttpInfo($location_id);
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdDeleteWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsync
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDeleteAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDelete'
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdDeleteRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDelete'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdGet
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation
     */
    public function restAccountingLocationsLocationIdGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdGetWithHttpInfo
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsync
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsyncWithHttpInfo
     *
     * Get an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGet
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsLocationIdPostingAccountsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsync
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGet
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration';
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration';
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/posting_key_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPut
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation
     */
    public function restAccountingLocationsLocationIdPut($location_id, $body = null)
    {
        list($response) = $this->restAccountingLocationsLocationIdPutWithHttpInfo($location_id, $body);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPutWithHttpInfo
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdPutWithHttpInfo($location_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsync
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPutAsync($location_id, $body = null)
    {
        return $this->restAccountingLocationsLocationIdPutAsyncWithHttpInfo($location_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsyncWithHttpInfo
     *
     * Update an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdPutAsyncWithHttpInfo($location_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPut'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdPutRequest($location_id, $body = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPut'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGet
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration';
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration';
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGet
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings
     */
    public function restAccountingLocationsLocationIdSettingsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdSettingsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdSettingsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings';
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsync
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdSettingsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings';
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdSettingsGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdSettingsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdSettingsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGet
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGet($location_id, $type)
    {
        list($response) = $this->restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo($location_id, $type);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo($location_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsync
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsync($location_id, $type)
    {
        return $this->restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo($location_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo($location_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdTypePostingAccountsGet'
     *
     * @param  int $location_id The ID of the accounting location. (required)
     * @param  string $type The type of the PostingAccount. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/{type}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPost
     *
     * Create an accounting location
     *
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation
     */
    public function restAccountingLocationsPost($body = null)
    {
        list($response) = $this->restAccountingLocationsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostWithHttpInfo
     *
     * Create an accounting location
     *
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostAsync
     *
     * Create an accounting location
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostAsync($body = null)
    {
        return $this->restAccountingLocationsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostAsyncWithHttpInfo
     *
     * Create an accounting location
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounting/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGet
     *
     * Get all posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsPostingAccountsGet()
    {
        list($response) = $this->restAccountingLocationsPostingAccountsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsync
     *
     * Get all posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsGetAsync()
    {
        return $this->restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsPostingAccountsGetRequest()
    {

        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDelete
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restAccountingLocationsPostingAccountsIdDelete($id)
    {
        $this->restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsync
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsync($id)
    {
        return $this->restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo
     *
     * Delete an posting account
     *
     * @param  int $id The ID of the posting account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdDelete'
     *
     * @param  int $id The ID of the posting account (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsPostingAccountsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdDelete'
            );
        }

        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGet
     *
     * Gets posting account by the unique id
     *
     * @param  int $id id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts
     */
    public function restAccountingLocationsPostingAccountsIdGet($id)
    {
        list($response) = $this->restAccountingLocationsPostingAccountsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsIdGetWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts';
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsync
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdGetAsync($id)
    {
        return $this->restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts';
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsPostingAccountsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPost
     *
     * Save posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsPostingAccountsPost()
    {
        list($response) = $this->restAccountingLocationsPostingAccountsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostWithHttpInfo
     *
     * Save posting accounts
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsPostingAccountsPostWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsync
     *
     * Save posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsPostAsync()
    {
        return $this->restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo
     *
     * Save posting accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsPostingAccountsPostRequest()
    {

        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGet
     *
     * List revenue account configurations
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsync
     *
     * List revenue account configurations
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsync($page = null, $items_per_page = null)
    {
        return $this->restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsRevenueAccountConfigurationsGet'
     *
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsRevenueAccountConfigurationsGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounting/locations/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 webstore_id2 (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet($country_id, $webstore_id, $webstore_id2)
    {
        list($response) = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo($country_id, $webstore_id, $webstore_id2);
        return $response;
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo($country_id, $webstore_id, $webstore_id2)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync($country_id, $webstore_id, $webstore_id2)
    {
        return $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo($country_id, $webstore_id, $webstore_id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo($country_id, $webstore_id, $webstore_id2)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
     *
     * @param  int $country_id The ID of the country (required)
     * @param  int $webstore_id The ID of the webstore (required)
     * @param  int $webstore_id2 (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2)
    {
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }
        // verify the required parameter 'webstore_id' is set
        if ($webstore_id === null || (is_array($webstore_id) && count($webstore_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webstore_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }
        // verify the required parameter 'webstore_id2' is set
        if ($webstore_id2 === null || (is_array($webstore_id2) && count($webstore_id2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webstore_id2 when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{webstoreId}/{countryId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($webstore_id !== null) {
            $queryParams['$webstoreId'] = ObjectSerializer::toQueryValue($webstore_id);
        }

        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($webstore_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'webstoreId' . '}',
                ObjectSerializer::toPathValue($webstore_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresLocationsGet
     *
     * List all accounting locations
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]
     */
    public function restAccountingStoresLocationsGet()
    {
        list($response) = $this->restAccountingStoresLocationsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingStoresLocationsGetWithHttpInfo
     *
     * List all accounting locations
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingStoresLocationsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresLocationsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresLocationsGetAsync
     *
     * List all accounting locations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingStoresLocationsGetAsync()
    {
        return $this->restAccountingStoresLocationsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresLocationsGetAsyncWithHttpInfo
     *
     * List all accounting locations
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingStoresLocationsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresLocationsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresLocationsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingStoresLocationsGetRequest()
    {

        $resourcePath = '/rest/accounting/stores/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGet
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id plenty_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]
     */
    public function restAccountingStoresPlentyIdLocationsGet($plenty_id)
    {
        list($response) = $this->restAccountingStoresPlentyIdLocationsGetWithHttpInfo($plenty_id);
        return $response;
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restAccountingStoresPlentyIdLocationsGetWithHttpInfo($plenty_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsync
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingStoresPlentyIdLocationsGetAsync($plenty_id)
    {
        return $this->restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param  int $plenty_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresPlentyIdLocationsGet'
     *
     * @param  int $plenty_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restAccountingStoresPlentyIdLocationsGetRequest($plenty_id)
    {
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restAccountingStoresPlentyIdLocationsGet'
            );
        }

        $resourcePath = '/rest/accounting/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStoresPlentyIdLocationsGet
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id plenty_id (required)
     * @param  int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation
     */
    public function restStoresPlentyIdLocationsGet($plenty_id, $country_id = null)
    {
        list($response) = $this->restStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $country_id);
        return $response;
    }

    /**
     * Operation restStoresPlentyIdLocationsGetWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     */
    public function restStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $country_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsync
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStoresPlentyIdLocationsGetAsync($plenty_id, $country_id = null)
    {
        return $this->restStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param  int $plenty_id (required)
     * @param  int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $country_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStoresPlentyIdLocationsGet'
     *
     * @param  int $plenty_id (required)
     * @param  int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id = null)
    {
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restStoresPlentyIdLocationsGet'
            );
        }

        $resourcePath = '/rest/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($country_id !== null) {
            $queryParams['countryId'] = ObjectSerializer::toQueryValue($country_id);
        }

        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatGet
     *
     * List VAT configurations.
     *
     * @param  int $page The requested page. (optional)
     * @param  int $items_per_page The number of items per page. (optional)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The properties to be loaded. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restVatGet($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        list($response) = $this->restVatGetWithHttpInfo($page, $items_per_page, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatGetWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param  int $page The requested page. (optional)
     * @param  int $items_per_page The number of items per page. (optional)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The properties to be loaded. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatGetWithHttpInfo($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        $returnType = 'object';
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatGetAsync
     *
     * List VAT configurations.
     *
     * @param  int $page The requested page. (optional)
     * @param  int $items_per_page The number of items per page. (optional)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The properties to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatGetAsync($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        return $this->restVatGetAsyncWithHttpInfo($page, $items_per_page, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatGetAsyncWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param  int $page The requested page. (optional)
     * @param  int $items_per_page The number of items per page. (optional)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The properties to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        $returnType = 'object';
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatGet'
     *
     * @param  int $page The requested page. (optional)
     * @param  int $items_per_page The number of items per page. (optional)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The properties to be loaded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatGetRequest($page = null, $items_per_page = null, $with = null, $columns = null)
    {

        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns'] = ObjectSerializer::toQueryValue($columns);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGet
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date date (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGet($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdDateDateGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  string $start_date The date of validity (required)
     * @param  int $date (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}/date/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGet
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]
     */
    public function restVatLocationsLocationIdCountriesCountryIdGet($location_id, $country_id, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo($location_id, $country_id, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo($location_id, $country_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsync
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsync($location_id, $country_id, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo($location_id, $country_id, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo($location_id, $country_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $country_id The ID of the country of delivery (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdGet
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection
     */
    public function restVatLocationsLocationIdGet($location_id, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdGetWithHttpInfo($location_id, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdGetWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatLocationsLocationIdGetWithHttpInfo($location_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdGetAsync
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdGetAsync($location_id, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdGetAsyncWithHttpInfo($location_id, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdGetAsyncWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatLocationsLocationIdGetAsyncWithHttpInfo($location_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdGet'
     *
     * @param  int $location_id The ID of the accounting location (required)
     * @param  int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param  int $columns The attributes of the VAT configuration (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatLocationsLocationIdGetRequest($location_id, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatPost
     *
     * Create a VAT configuration
     *
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat
     */
    public function restVatPost($body = null)
    {
        list($response) = $this->restVatPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restVatPostWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatPostWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatPostAsync
     *
     * Create a VAT configuration
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatPostAsync($body = null)
    {
        return $this->restVatPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatPostAsyncWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatPostRequest($body = null)
    {

        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatStandardGet
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int $plenty_id The plenty ID of the client (store) (optional)
     * @param  string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat
     */
    public function restVatStandardGet($plenty_id = null, $started_at = null)
    {
        list($response) = $this->restVatStandardGetWithHttpInfo($plenty_id, $started_at);
        return $response;
    }

    /**
     * Operation restVatStandardGetWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int $plenty_id The plenty ID of the client (store) (optional)
     * @param  string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatStandardGetWithHttpInfo($plenty_id = null, $started_at = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatStandardGetAsync
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int $plenty_id The plenty ID of the client (store) (optional)
     * @param  string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatStandardGetAsync($plenty_id = null, $started_at = null)
    {
        return $this->restVatStandardGetAsyncWithHttpInfo($plenty_id, $started_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatStandardGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param  int $plenty_id The plenty ID of the client (store) (optional)
     * @param  string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatStandardGetAsyncWithHttpInfo($plenty_id = null, $started_at = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatStandardGet'
     *
     * @param  int $plenty_id The plenty ID of the client (store) (optional)
     * @param  string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatStandardGetRequest($plenty_id = null, $started_at = null)
    {

        $resourcePath = '/rest/vat/standard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = ObjectSerializer::toQueryValue($plenty_id);
        }
        // query params
        if ($started_at !== null) {
            $queryParams['startedAt'] = ObjectSerializer::toQueryValue($started_at);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdGet
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id vat_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat
     */
    public function restVatVatIdGet($vat_id)
    {
        list($response) = $this->restVatVatIdGetWithHttpInfo($vat_id);
        return $response;
    }

    /**
     * Operation restVatVatIdGetWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatVatIdGetWithHttpInfo($vat_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdGetRequest($vat_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdGetAsync
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatVatIdGetAsync($vat_id)
    {
        return $this->restVatVatIdGetAsyncWithHttpInfo($vat_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdGetAsyncWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param  int $vat_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatVatIdGetAsyncWithHttpInfo($vat_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdGetRequest($vat_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdGet'
     *
     * @param  int $vat_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatVatIdGetRequest($vat_id)
    {
        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdGet'
            );
        }

        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdPut
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id vat_id (required)
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat
     */
    public function restVatVatIdPut($vat_id, $body = null)
    {
        list($response) = $this->restVatVatIdPutWithHttpInfo($vat_id, $body);
        return $response;
    }

    /**
     * Operation restVatVatIdPutWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     */
    public function restVatVatIdPutWithHttpInfo($vat_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdPutRequest($vat_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdPutAsync
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatVatIdPutAsync($vat_id, $body = null)
    {
        return $this->restVatVatIdPutAsyncWithHttpInfo($vat_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdPutAsyncWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param  int $vat_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restVatVatIdPutAsyncWithHttpInfo($vat_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdPutRequest($vat_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdPut'
     *
     * @param  int $vat_id (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restVatVatIdPutRequest($vat_id, $body = null)
    {
        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdPut'
            );
        }

        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
