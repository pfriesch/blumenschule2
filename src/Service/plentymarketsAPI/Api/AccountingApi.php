<?php
/**
 * AccountingApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use function GuzzleHttp\Psr7\build_query;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;
use InvalidArgumentException;
use RuntimeException;
use stdClass;

/**
 * AccountingApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    )
    {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGet
     *
     * Get all unique posting accounts
     *
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsExistingAccountsGet()
    {
        list($response) = $this->restAccountingLocationsExistingAccountsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetWithHttpInfo
     *
     * Get all unique posting accounts
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsExistingAccountsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsExistingAccountsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsync
     *
     * Get all unique posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsExistingAccountsGetAsync()
    {
        return $this->restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo
     *
     * Get all unique posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsExistingAccountsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsExistingAccountsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsExistingAccountsGet'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsExistingAccountsGetRequest()
    {

        $resourcePath = '/rest/accounting/locations/existing_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet
     *
     * Get the revenue account configuration of a country
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param int $country_id The ID of the country. (required)
     *
     * @return PlentyModulesAccountingModelsRevenueAccountCountryConfiguration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet($location_id, $country_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo($location_id, $country_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param int $country_id The ID of the country. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetWithHttpInfo($location_id, $country_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration';
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync
     *
     * Get the revenue account configuration of a country
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param int $country_id The ID of the country. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsync($location_id, $country_id)
    {
        return $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo($location_id, $country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of a country
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param int $country_id The ID of the country. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetAsyncWithHttpInfo($location_id, $country_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountCountryConfiguration';
        $request = $this->restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param int $country_id The ID of the country. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGetRequest($location_id, $country_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsLocationIdCountriesCountryIdRevenueAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/countries/{countryId}/revenue_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGet
     *
     * Get debtor account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PlentyModulesAccountingModelsDebtorAccountConfiguration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync
     *
     * Get debtor account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get debtor account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsDebtorAccountConfiguration';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdDebtorAccountConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGet
     *
     * Lists the debtor accounts by mode.
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @return IlluminateSupportCollection
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGet($location_id, $mode)
    {
        list($response) = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo($location_id, $mode);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetWithHttpInfo($location_id, $mode)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsync
     *
     * Lists the debtor accounts by mode.
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsync($location_id, $mode)
    {
        return $this->restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo($location_id, $mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo
     *
     * Lists the debtor accounts by mode.
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDebtorAccountsModeGetAsyncWithHttpInfo($location_id, $mode)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDebtorAccountsModeGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $mode The mode defines how pending amounts are assigned to debtor accounts. The following modes are available:      &lt;ul&gt;       &lt;li&gt;character        &#x3D; The debtor accounts are selected based on the first character of customer information. The information and the order of the information that will be used are defined with the sequence. There are 3 different sequences available.&lt;/li&gt;       &lt;li&gt;payment          &#x3D; The debtor accounts are selected based on the payment method.&lt;/li&gt;       &lt;li&gt;country          &#x3D; The debtor accounts are selected based on the country of delivery.&lt;/li&gt;       &lt;li&gt;country_payment  &#x3D; The debtor accounts are selected based on two criteria. The first criteria is the country and if the country is same as the country of the accounting location then the payment method is used to select the deptor account.&lt;/li&gt;      &lt;/ul&gt; (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdDebtorAccountsModeGetRequest($location_id, $mode)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $mode when calling restAccountingLocationsLocationIdDebtorAccountsModeGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/debtor_accounts/{mode}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($mode !== null) {
            $resourcePath = str_replace(
                '{' . 'mode' . '}',
                ObjectSerializer::toPathValue($mode),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdDelete
     *
     * Delete an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDelete($location_id)
    {
        $this->restAccountingLocationsLocationIdDeleteWithHttpInfo($location_id);
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdDeleteWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsync
     *
     * Delete an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDeleteAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo
     *
     * Delete an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdDeleteAsyncWithHttpInfo($location_id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsLocationIdDeleteRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdDelete'
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdDeleteRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdDelete'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdGet
     *
     * Get an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PlentyModulesAccountingModelsAccountingLocation
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdGetWithHttpInfo
     *
     * Get an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsync
     *
     * Get an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdGetAsyncWithHttpInfo
     *
     * Get an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdGet'
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGet
     *
     * Get all posting accounts by locationId
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPostingAccountsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsync
     *
     * Get all posting accounts by locationId
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPostingAccountsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingAccountsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdPostingAccountsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGet
     *
     * Get a posting key configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PlentyModulesAccountingModelsPostingKeyConfiguration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration';
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync
     *
     * Get a posting key configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo
     *
     * Get a posting key configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPostingKeyConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingKeyConfiguration';
        $request = $this->restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdPostingKeyConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPostingKeyConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/posting_key_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdPut
     *
     * Update an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param object $body body (optional)
     *
     * @return PlentyModulesAccountingModelsAccountingLocation
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPut($location_id, $body = null)
    {
        list($response) = $this->restAccountingLocationsLocationIdPutWithHttpInfo($location_id, $body);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdPutWithHttpInfo
     *
     * Update an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param object $body (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdPutWithHttpInfo($location_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsync
     *
     * Update an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPutAsync($location_id, $body = null)
    {
        return $this->restAccountingLocationsLocationIdPutAsyncWithHttpInfo($location_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdPutAsyncWithHttpInfo
     *
     * Update an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdPutAsyncWithHttpInfo($location_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsLocationIdPutRequest($location_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdPut'
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param object $body (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdPutRequest($location_id, $body = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdPut'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGet
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PlentyModulesAccountingModelsRevenueAccountLocationConfiguration
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration';
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * Get the revenue account configuration of an accounting location
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsRevenueAccountLocationConfiguration';
        $request = $this->restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdRevenueAccountConfigurationsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdRevenueAccountConfigurationsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGet
     *
     * Get accounting location settings
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PlentyModulesAccountingModelsAccountingLocationSettings
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdSettingsGet($location_id)
    {
        list($response) = $this->restAccountingLocationsLocationIdSettingsGetWithHttpInfo($location_id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdSettingsGetWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings';
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsync
     *
     * Get accounting location settings
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdSettingsGetAsync($location_id)
    {
        return $this->restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo($location_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo
     *
     * Get accounting location settings
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdSettingsGetAsyncWithHttpInfo($location_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocationSettings';
        $request = $this->restAccountingLocationsLocationIdSettingsGetRequest($location_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdSettingsGet'
     *
     * @param int $location_id The ID of the accounting location (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdSettingsGetRequest($location_id)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdSettingsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGet
     *
     * Get all posting accounts by locationId and type
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $type The type of the PostingAccount. (required)
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGet($location_id, $type)
    {
        list($response) = $this->restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo($location_id, $type);
        return $response;
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $type The type of the PostingAccount. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetWithHttpInfo($location_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsync
     *
     * Get all posting accounts by locationId and type
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $type The type of the PostingAccount. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsync($location_id, $type)
    {
        return $this->restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo($location_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts by locationId and type
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $type The type of the PostingAccount. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsLocationIdTypePostingAccountsGetAsyncWithHttpInfo($location_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsLocationIdTypePostingAccountsGet'
     *
     * @param int $location_id The ID of the accounting location. (required)
     * @param string $type The type of the PostingAccount. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsLocationIdTypePostingAccountsGetRequest($location_id, $type)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $type when calling restAccountingLocationsLocationIdTypePostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{locationId}/{type}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPost
     *
     * Create an accounting location
     *
     * @param object $body body (optional)
     *
     * @return PlentyModulesAccountingModelsAccountingLocation
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPost($body = null)
    {
        list($response) = $this->restAccountingLocationsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostWithHttpInfo
     *
     * Create an accounting location
     *
     * @param object $body (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostAsync
     *
     * Create an accounting location
     *
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostAsync($body = null)
    {
        return $this->restAccountingLocationsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostAsyncWithHttpInfo
     *
     * Create an accounting location
     *
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restAccountingLocationsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPost'
     *
     * @param object $body (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsPostRequest($body = null)
    {

        $resourcePath = '/rest/accounting/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGet
     *
     * Get all posting accounts
     *
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsGet()
    {
        list($response) = $this->restAccountingLocationsPostingAccountsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsync
     *
     * Get all posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsGetAsync()
    {
        return $this->restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsGet'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsPostingAccountsGetRequest()
    {

        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDelete
     *
     * Delete an posting account
     *
     * @param int $id The ID of the posting account (required)
     *
     * @return void
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsIdDelete($id)
    {
        $this->restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo($id);
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo
     *
     * Delete an posting account
     *
     * @param int $id The ID of the posting account (required)
     *
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsIdDeleteWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsync
     *
     * Delete an posting account
     *
     * @param int $id The ID of the posting account (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsync($id)
    {
        return $this->restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo
     *
     * Delete an posting account
     *
     * @param int $id The ID of the posting account (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsIdDeleteAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->restAccountingLocationsPostingAccountsIdDeleteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdDelete'
     *
     * @param int $id The ID of the posting account (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsPostingAccountsIdDeleteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdDelete'
            );
        }

        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGet
     *
     * Gets posting account by the unique id
     *
     * @param int $id id (required)
     *
     * @return PlentyModulesAccountingModelsPostingAccounts
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsIdGet($id)
    {
        list($response) = $this->restAccountingLocationsPostingAccountsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param int $id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsIdGetWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts';
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsync
     *
     * Gets posting account by the unique id
     *
     * @param int $id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsIdGetAsync($id)
    {
        return $this->restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo
     *
     * Gets posting account by the unique id
     *
     * @param int $id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts';
        $request = $this->restAccountingLocationsPostingAccountsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsIdGet'
     *
     * @param int $id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsPostingAccountsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling restAccountingLocationsPostingAccountsIdGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/posting_accounts/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPost
     *
     * Save posting accounts
     *
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsPost()
    {
        list($response) = $this->restAccountingLocationsPostingAccountsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostWithHttpInfo
     *
     * Save posting accounts
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsPostingAccountsPostWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsync
     *
     * Save posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsPostAsync()
    {
        return $this->restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo
     *
     * Save posting accounts
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsPostingAccountsPostAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsPostingAccountsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsPostingAccountsPost'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsPostingAccountsPostRequest()
    {

        $resourcePath = '/rest/accounting/locations/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGet
     *
     * List revenue account configurations
     *
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @return object
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGet($page = null, $items_per_page = null)
    {
        list($response) = $this->restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo($page, $items_per_page);
        return $response;
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsync
     *
     * List revenue account configurations
     *
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsync($page = null, $items_per_page = null)
    {
        return $this->restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo($page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo
     *
     * List revenue account configurations
     *
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsRevenueAccountConfigurationsGetAsyncWithHttpInfo($page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restAccountingLocationsRevenueAccountConfigurationsGetRequest($page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsRevenueAccountConfigurationsGet'
     *
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of revenue accounts to be displayed per page. The default number of orders per page is 50. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsRevenueAccountConfigurationsGetRequest($page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/accounting/locations/revenue_account_configurations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param int $country_id The ID of the country (required)
     * @param int $webstore_id The ID of the webstore (required)
     * @param int $webstore_id2 webstore_id2 (required)
     *
     * @return PlentyModulesAccountingModelsPostingAccounts[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet($country_id, $webstore_id, $webstore_id2)
    {
        list($response) = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo($country_id, $webstore_id, $webstore_id2);
        return $response;
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param int $country_id The ID of the country (required)
     * @param int $webstore_id The ID of the webstore (required)
     * @param int $webstore_id2 (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetWithHttpInfo($country_id, $webstore_id, $webstore_id2)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param int $country_id The ID of the country (required)
     * @param int $webstore_id The ID of the webstore (required)
     * @param int $webstore_id2 (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsync($country_id, $webstore_id, $webstore_id2)
    {
        return $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo($country_id, $webstore_id, $webstore_id2)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo
     *
     * Get all posting accounts for a country of a webstore
     *
     * @param int $country_id The ID of the country (required)
     * @param int $webstore_id The ID of the webstore (required)
     * @param int $webstore_id2 (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetAsyncWithHttpInfo($country_id, $webstore_id, $webstore_id2)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsPostingAccounts[]';
        $request = $this->restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
     *
     * @param int $country_id The ID of the country (required)
     * @param int $webstore_id The ID of the webstore (required)
     * @param int $webstore_id2 (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingLocationsWebstoreIdCountryIdPostingAccountsGetRequest($country_id, $webstore_id, $webstore_id2)
    {
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }
        // verify the required parameter 'webstore_id' is set
        if ($webstore_id === null || (is_array($webstore_id) && count($webstore_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webstore_id when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }
        // verify the required parameter 'webstore_id2' is set
        if ($webstore_id2 === null || (is_array($webstore_id2) && count($webstore_id2) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webstore_id2 when calling restAccountingLocationsWebstoreIdCountryIdPostingAccountsGet'
            );
        }

        $resourcePath = '/rest/accounting/locations/{webstoreId}/{countryId}/posting_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($webstore_id !== null) {
            $queryParams['$webstoreId'] = ObjectSerializer::toQueryValue($webstore_id);
        }

        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($webstore_id2 !== null) {
            $resourcePath = str_replace(
                '{' . 'webstoreId' . '}',
                ObjectSerializer::toPathValue($webstore_id2),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresLocationsGet
     *
     * List all accounting locations
     *
     *
     * @return PlentyModulesAccountingModelsAccountingLocation[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingStoresLocationsGet()
    {
        list($response) = $this->restAccountingStoresLocationsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restAccountingStoresLocationsGetWithHttpInfo
     *
     * List all accounting locations
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingStoresLocationsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresLocationsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresLocationsGetAsync
     *
     * List all accounting locations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingStoresLocationsGetAsync()
    {
        return $this->restAccountingStoresLocationsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresLocationsGetAsyncWithHttpInfo
     *
     * List all accounting locations
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingStoresLocationsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresLocationsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresLocationsGet'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingStoresLocationsGetRequest()
    {

        $resourcePath = '/rest/accounting/stores/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGet
     *
     * List accounting locations of a client
     *
     * @param int $plenty_id plenty_id (required)
     *
     * @return PlentyModulesAccountingModelsAccountingLocation[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingStoresPlentyIdLocationsGet($plenty_id)
    {
        list($response) = $this->restAccountingStoresPlentyIdLocationsGetWithHttpInfo($plenty_id);
        return $response;
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param int $plenty_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restAccountingStoresPlentyIdLocationsGetWithHttpInfo($plenty_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsync
     *
     * List accounting locations of a client
     *
     * @param int $plenty_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingStoresPlentyIdLocationsGetAsync($plenty_id)
    {
        return $this->restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * List accounting locations of a client
     *
     * @param int $plenty_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restAccountingStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation[]';
        $request = $this->restAccountingStoresPlentyIdLocationsGetRequest($plenty_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restAccountingStoresPlentyIdLocationsGet'
     *
     * @param int $plenty_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restAccountingStoresPlentyIdLocationsGetRequest($plenty_id)
    {
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restAccountingStoresPlentyIdLocationsGet'
            );
        }

        $resourcePath = '/rest/accounting/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restStoresPlentyIdLocationsGet
     *
     * Get the ID of an accounting location of a country
     *
     * @param int $plenty_id plenty_id (required)
     * @param int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @return PlentyModulesAccountingModelsAccountingLocation
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restStoresPlentyIdLocationsGet($plenty_id, $country_id = null)
    {
        list($response) = $this->restStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $country_id);
        return $response;
    }

    /**
     * Operation restStoresPlentyIdLocationsGetWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param int $plenty_id (required)
     * @param int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restStoresPlentyIdLocationsGetWithHttpInfo($plenty_id, $country_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsync
     *
     * Get the ID of an accounting location of a country
     *
     * @param int $plenty_id (required)
     * @param int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restStoresPlentyIdLocationsGetAsync($plenty_id, $country_id = null)
    {
        return $this->restStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $country_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restStoresPlentyIdLocationsGetAsyncWithHttpInfo
     *
     * Get the ID of an accounting location of a country
     *
     * @param int $plenty_id (required)
     * @param int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restStoresPlentyIdLocationsGetAsyncWithHttpInfo($plenty_id, $country_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingModelsAccountingLocation';
        $request = $this->restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restStoresPlentyIdLocationsGet'
     *
     * @param int $plenty_id (required)
     * @param int $country_id The ID of the country of the accounting location. The default accounting location of the client will be returned if the ID of a country is not specified. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restStoresPlentyIdLocationsGetRequest($plenty_id, $country_id = null)
    {
        // verify the required parameter 'plenty_id' is set
        if ($plenty_id === null || (is_array($plenty_id) && count($plenty_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $plenty_id when calling restStoresPlentyIdLocationsGet'
            );
        }

        $resourcePath = '/rest/stores/{plentyId}/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($country_id !== null) {
            $queryParams['countryId'] = ObjectSerializer::toQueryValue($country_id);
        }

        // path params
        if ($plenty_id !== null) {
            $resourcePath = str_replace(
                '{' . 'plentyId' . '}',
                ObjectSerializer::toPathValue($plenty_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatGet
     *
     * List VAT configurations.
     *
     * @param int $page The requested page. (optional)
     * @param int $items_per_page The number of items per page. (optional)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The properties to be loaded. (optional)
     *
     * @return object
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatGet($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        list($response) = $this->restVatGetWithHttpInfo($page, $items_per_page, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatGetWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param int $page The requested page. (optional)
     * @param int $items_per_page The number of items per page. (optional)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The properties to be loaded. (optional)
     *
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatGetWithHttpInfo($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        $returnType = 'object';
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatGetAsync
     *
     * List VAT configurations.
     *
     * @param int $page The requested page. (optional)
     * @param int $items_per_page The number of items per page. (optional)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The properties to be loaded. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatGetAsync($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        return $this->restVatGetAsyncWithHttpInfo($page, $items_per_page, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatGetAsyncWithHttpInfo
     *
     * List VAT configurations.
     *
     * @param int $page The requested page. (optional)
     * @param int $items_per_page The number of items per page. (optional)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The properties to be loaded. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatGetAsyncWithHttpInfo($page = null, $items_per_page = null, $with = null, $columns = null)
    {
        $returnType = 'object';
        $request = $this->restVatGetRequest($page, $items_per_page, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatGet'
     *
     * @param int $page The requested page. (optional)
     * @param int $items_per_page The number of items per page. (optional)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The properties to be loaded. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatGetRequest($page = null, $items_per_page = null, $with = null, $columns = null)
    {

        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns'] = ObjectSerializer::toQueryValue($columns);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGet
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param string $start_date The date of validity (required)
     * @param int $date date (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PlentyModulesAccountingVatModelsVat
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGet($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param string $start_date The date of validity (required)
     * @param int $date (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetWithHttpInfo($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param string $start_date The date of validity (required)
     * @param int $date (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsync($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo($location_id, $country_id, $start_date, $date, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for a country in a location.
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param string $start_date The date of validity (required)
     * @param int $date (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdCountriesCountryIdDateDateGetAsyncWithHttpInfo($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdDateDateGet'
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param string $start_date The date of validity (required)
     * @param int $date (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatLocationsLocationIdCountriesCountryIdDateDateGetRequest($location_id, $country_id, $start_date, $date, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $start_date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $date when calling restVatLocationsLocationIdCountriesCountryIdDateDateGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}/date/{date}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date);
        }
        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }
        // path params
        if ($date !== null) {
            $resourcePath = str_replace(
                '{' . 'date' . '}',
                ObjectSerializer::toPathValue($date),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGet
     *
     * List VAT configurations for one country of delivery
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PlentyModulesAccountingVatModelsVat[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdCountriesCountryIdGet($location_id, $country_id, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo($location_id, $country_id, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetWithHttpInfo($location_id, $country_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsync
     *
     * List VAT configurations for one country of delivery
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsync($location_id, $country_id, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo($location_id, $country_id, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo
     *
     * List VAT configurations for one country of delivery
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdCountriesCountryIdGetAsyncWithHttpInfo($location_id, $country_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat[]';
        $request = $this->restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdCountriesCountryIdGet'
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $country_id The ID of the country of delivery (required)
     * @param int $with The relations to load with the VAT object. The relations available are location or country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatLocationsLocationIdCountriesCountryIdGetRequest($location_id, $country_id, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }
        // verify the required parameter 'country_id' is set
        if ($country_id === null || (is_array($country_id) && count($country_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $country_id when calling restVatLocationsLocationIdCountriesCountryIdGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}/countries/{countryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($country_id !== null) {
            $resourcePath = str_replace(
                '{' . 'countryId' . '}',
                ObjectSerializer::toPathValue($country_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatLocationsLocationIdGet
     *
     * List VAT configurations of an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return IlluminateSupportCollection
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdGet($location_id, $with = null, $columns = null)
    {
        list($response) = $this->restVatLocationsLocationIdGetWithHttpInfo($location_id, $with, $columns);
        return $response;
    }

    /**
     * Operation restVatLocationsLocationIdGetWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatLocationsLocationIdGetWithHttpInfo($location_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatLocationsLocationIdGetAsync
     *
     * List VAT configurations of an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdGetAsync($location_id, $with = null, $columns = null)
    {
        return $this->restVatLocationsLocationIdGetAsyncWithHttpInfo($location_id, $with, $columns)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatLocationsLocationIdGetAsyncWithHttpInfo
     *
     * List VAT configurations of an accounting location
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatLocationsLocationIdGetAsyncWithHttpInfo($location_id, $with = null, $columns = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\IlluminateSupportCollection';
        $request = $this->restVatLocationsLocationIdGetRequest($location_id, $with, $columns);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatLocationsLocationIdGet'
     *
     * @param int $location_id The ID of the accounting location (required)
     * @param int $with The relations to load with the VAT object. The relations available are location and country. (optional)
     * @param int $columns The attributes of the VAT configuration (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatLocationsLocationIdGetRequest($location_id, $with = null, $columns = null)
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling restVatLocationsLocationIdGet'
            );
        }

        $resourcePath = '/rest/vat/locations/{locationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with[]'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($columns !== null) {
            $queryParams['columns[]'] = ObjectSerializer::toQueryValue($columns);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatPost
     *
     * Create a VAT configuration
     *
     * @param object $body body (optional)
     *
     * @return PlentyModulesAccountingVatModelsVat
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatPost($body = null)
    {
        list($response) = $this->restVatPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restVatPostWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param object $body (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatPostWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatPostAsync
     *
     * Create a VAT configuration
     *
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatPostAsync($body = null)
    {
        return $this->restVatPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatPostAsyncWithHttpInfo
     *
     * Create a VAT configuration
     *
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatPost'
     *
     * @param object $body (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatPostRequest($body = null)
    {

        $resourcePath = '/rest/vat';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatStandardGet
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param int $plenty_id The plenty ID of the client (store) (optional)
     * @param string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @return PlentyModulesAccountingVatModelsVat
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatStandardGet($plenty_id = null, $started_at = null)
    {
        list($response) = $this->restVatStandardGetWithHttpInfo($plenty_id, $started_at);
        return $response;
    }

    /**
     * Operation restVatStandardGetWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param int $plenty_id The plenty ID of the client (store) (optional)
     * @param string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatStandardGetWithHttpInfo($plenty_id = null, $started_at = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatStandardGetAsync
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param int $plenty_id The plenty ID of the client (store) (optional)
     * @param string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatStandardGetAsync($plenty_id = null, $started_at = null)
    {
        return $this->restVatStandardGetAsyncWithHttpInfo($plenty_id, $started_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatStandardGetAsyncWithHttpInfo
     *
     * Get a VAT configuration for the standard accounting location of a client
     *
     * @param int $plenty_id The plenty ID of the client (store) (optional)
     * @param string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatStandardGetAsyncWithHttpInfo($plenty_id = null, $started_at = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatStandardGetRequest($plenty_id, $started_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatStandardGet'
     *
     * @param int $plenty_id The plenty ID of the client (store) (optional)
     * @param string $started_at The date in the W3C format when the vat configuration went into effect (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatStandardGetRequest($plenty_id = null, $started_at = null)
    {

        $resourcePath = '/rest/vat/standard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = ObjectSerializer::toQueryValue($plenty_id);
        }
        // query params
        if ($started_at !== null) {
            $queryParams['startedAt'] = ObjectSerializer::toQueryValue($started_at);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdGet
     *
     * Get a VAT configuration by id
     *
     * @param int $vat_id vat_id (required)
     *
     * @return PlentyModulesAccountingVatModelsVat
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatVatIdGet($vat_id)
    {
        list($response) = $this->restVatVatIdGetWithHttpInfo($vat_id);
        return $response;
    }

    /**
     * Operation restVatVatIdGetWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param int $vat_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatVatIdGetWithHttpInfo($vat_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdGetRequest($vat_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdGetAsync
     *
     * Get a VAT configuration by id
     *
     * @param int $vat_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatVatIdGetAsync($vat_id)
    {
        return $this->restVatVatIdGetAsyncWithHttpInfo($vat_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdGetAsyncWithHttpInfo
     *
     * Get a VAT configuration by id
     *
     * @param int $vat_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatVatIdGetAsyncWithHttpInfo($vat_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdGetRequest($vat_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdGet'
     *
     * @param int $vat_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatVatIdGetRequest($vat_id)
    {
        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdGet'
            );
        }

        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restVatVatIdPut
     *
     * Update a VAT configuration
     *
     * @param int $vat_id vat_id (required)
     * @param object $body body (optional)
     *
     * @return PlentyModulesAccountingVatModelsVat
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatVatIdPut($vat_id, $body = null)
    {
        list($response) = $this->restVatVatIdPutWithHttpInfo($vat_id, $body);
        return $response;
    }

    /**
     * Operation restVatVatIdPutWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param int $vat_id (required)
     * @param object $body (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restVatVatIdPutWithHttpInfo($vat_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdPutRequest($vat_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restVatVatIdPutAsync
     *
     * Update a VAT configuration
     *
     * @param int $vat_id (required)
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatVatIdPutAsync($vat_id, $body = null)
    {
        return $this->restVatVatIdPutAsyncWithHttpInfo($vat_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restVatVatIdPutAsyncWithHttpInfo
     *
     * Update a VAT configuration
     *
     * @param int $vat_id (required)
     * @param object $body (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restVatVatIdPutAsyncWithHttpInfo($vat_id, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountingVatModelsVat';
        $request = $this->restVatVatIdPutRequest($vat_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restVatVatIdPut'
     *
     * @param int $vat_id (required)
     * @param object $body (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restVatVatIdPutRequest($vat_id, $body = null)
    {
        // verify the required parameter 'vat_id' is set
        if ($vat_id === null || (is_array($vat_id) && count($vat_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vat_id when calling restVatVatIdPut'
            );
        }

        $resourcePath = '/rest/vat/{vatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($vat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'vatId' . '}',
                ObjectSerializer::toPathValue($vat_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @return array of http client options
     * @throws RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
