<?php
/**
 * LogApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;

/**
 * LogApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LogApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restDeleteLogGet
     *
     * Search the delete log
     *
     * @param  int $reference_type The type of deleted record (optional)
     * @param  int $user_id The ID of the user who deleted the record (optional)
     * @param  string $updated_between Filter restricts the list of results to deleteLogs updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../delete_log?updatedBetween&#x3D;1451606400,1456790400 will list deleteLogs updated between 2016-01-01 and 2016-03-01. .../delete_log?updatedBetween&#x3D;1451606400 will list deleteLogs updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restDeleteLogGet($reference_type = null, $user_id = null, $updated_between = null, $page = null, $items_per_page = null)
    {
        list($response) = $this->restDeleteLogGetWithHttpInfo($reference_type, $user_id, $updated_between, $page, $items_per_page);
        return $response;
    }

    /**
     * Operation restDeleteLogGetWithHttpInfo
     *
     * Search the delete log
     *
     * @param  int $reference_type The type of deleted record (optional)
     * @param  int $user_id The ID of the user who deleted the record (optional)
     * @param  string $updated_between Filter restricts the list of results to deleteLogs updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../delete_log?updatedBetween&#x3D;1451606400,1456790400 will list deleteLogs updated between 2016-01-01 and 2016-03-01. .../delete_log?updatedBetween&#x3D;1451606400 will list deleteLogs updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDeleteLogGetWithHttpInfo($reference_type = null, $user_id = null, $updated_between = null, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restDeleteLogGetRequest($reference_type, $user_id, $updated_between, $page, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDeleteLogGetAsync
     *
     * Search the delete log
     *
     * @param  int $reference_type The type of deleted record (optional)
     * @param  int $user_id The ID of the user who deleted the record (optional)
     * @param  string $updated_between Filter restricts the list of results to deleteLogs updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../delete_log?updatedBetween&#x3D;1451606400,1456790400 will list deleteLogs updated between 2016-01-01 and 2016-03-01. .../delete_log?updatedBetween&#x3D;1451606400 will list deleteLogs updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeleteLogGetAsync($reference_type = null, $user_id = null, $updated_between = null, $page = null, $items_per_page = null)
    {
        return $this->restDeleteLogGetAsyncWithHttpInfo($reference_type, $user_id, $updated_between, $page, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDeleteLogGetAsyncWithHttpInfo
     *
     * Search the delete log
     *
     * @param  int $reference_type The type of deleted record (optional)
     * @param  int $user_id The ID of the user who deleted the record (optional)
     * @param  string $updated_between Filter restricts the list of results to deleteLogs updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../delete_log?updatedBetween&#x3D;1451606400,1456790400 will list deleteLogs updated between 2016-01-01 and 2016-03-01. .../delete_log?updatedBetween&#x3D;1451606400 will list deleteLogs updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDeleteLogGetAsyncWithHttpInfo($reference_type = null, $user_id = null, $updated_between = null, $page = null, $items_per_page = null)
    {
        $returnType = 'object';
        $request = $this->restDeleteLogGetRequest($reference_type, $user_id, $updated_between, $page, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDeleteLogGet'
     *
     * @param  int $reference_type The type of deleted record (optional)
     * @param  int $user_id The ID of the user who deleted the record (optional)
     * @param  string $updated_between Filter restricts the list of results to deleteLogs updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../delete_log?updatedBetween&#x3D;1451606400,1456790400 will list deleteLogs updated between 2016-01-01 and 2016-03-01. .../delete_log?updatedBetween&#x3D;1451606400 will list deleteLogs updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param  int $page The page of results to search for (optional)
     * @param  int $items_per_page The number of items to list per page (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDeleteLogGetRequest($reference_type = null, $user_id = null, $updated_between = null, $page = null, $items_per_page = null)
    {

        $resourcePath = '/rest/delete_log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reference_type !== null) {
            $queryParams['referenceType'] = ObjectSerializer::toQueryValue($reference_type);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }
        // query params
        if ($updated_between !== null) {
            $queryParams['updatedBetween'] = ObjectSerializer::toQueryValue($updated_between);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsGet
     *
     * Perform a search operation.
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $integration Filter that restricts the search result to log entries with custom integration key(s). (optional)
     * @param  int $identifier Filter that restricts the search result to log entries with custom identifier(s). (optional)
     * @param  string $reference_type Filter that restricts the search result to log entries with custom reference types. (optional)
     * @param  string $reference_value Filter that restricts the search result to log entries with custom reference values. (optional)
     * @param  string $additional_info Filter that restricts the search result to log entries that match an additional info. (optional)
     * @param  int $code Filter that restricts the search result to log entries with a custom code. (optional)
     * @param  int $level Filter that restricts the search result to log entries of a custom level. Available values are: &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;notice&#x27;, &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;critical&#x27;, &#x27;alert&#x27;, &#x27;emergency&#x27;. (optional)
     * @param  string $from_date Filter that restricts the search result to log entries created after this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $to_date Filter that restricts the search result to log entries created before this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;additionalInfo&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restLogsGet($page = null, $items_per_page = null, $integration = null, $identifier = null, $reference_type = null, $reference_value = null, $additional_info = null, $code = null, $level = null, $from_date = null, $to_date = null, $with = null)
    {
        list($response) = $this->restLogsGetWithHttpInfo($page, $items_per_page, $integration, $identifier, $reference_type, $reference_value, $additional_info, $code, $level, $from_date, $to_date, $with);
        return $response;
    }

    /**
     * Operation restLogsGetWithHttpInfo
     *
     * Perform a search operation.
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $integration Filter that restricts the search result to log entries with custom integration key(s). (optional)
     * @param  int $identifier Filter that restricts the search result to log entries with custom identifier(s). (optional)
     * @param  string $reference_type Filter that restricts the search result to log entries with custom reference types. (optional)
     * @param  string $reference_value Filter that restricts the search result to log entries with custom reference values. (optional)
     * @param  string $additional_info Filter that restricts the search result to log entries that match an additional info. (optional)
     * @param  int $code Filter that restricts the search result to log entries with a custom code. (optional)
     * @param  int $level Filter that restricts the search result to log entries of a custom level. Available values are: &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;notice&#x27;, &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;critical&#x27;, &#x27;alert&#x27;, &#x27;emergency&#x27;. (optional)
     * @param  string $from_date Filter that restricts the search result to log entries created after this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $to_date Filter that restricts the search result to log entries created before this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;additionalInfo&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsGetWithHttpInfo($page = null, $items_per_page = null, $integration = null, $identifier = null, $reference_type = null, $reference_value = null, $additional_info = null, $code = null, $level = null, $from_date = null, $to_date = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restLogsGetRequest($page, $items_per_page, $integration, $identifier, $reference_type, $reference_value, $additional_info, $code, $level, $from_date, $to_date, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsGetAsync
     *
     * Perform a search operation.
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $integration Filter that restricts the search result to log entries with custom integration key(s). (optional)
     * @param  int $identifier Filter that restricts the search result to log entries with custom identifier(s). (optional)
     * @param  string $reference_type Filter that restricts the search result to log entries with custom reference types. (optional)
     * @param  string $reference_value Filter that restricts the search result to log entries with custom reference values. (optional)
     * @param  string $additional_info Filter that restricts the search result to log entries that match an additional info. (optional)
     * @param  int $code Filter that restricts the search result to log entries with a custom code. (optional)
     * @param  int $level Filter that restricts the search result to log entries of a custom level. Available values are: &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;notice&#x27;, &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;critical&#x27;, &#x27;alert&#x27;, &#x27;emergency&#x27;. (optional)
     * @param  string $from_date Filter that restricts the search result to log entries created after this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $to_date Filter that restricts the search result to log entries created before this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;additionalInfo&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsGetAsync($page = null, $items_per_page = null, $integration = null, $identifier = null, $reference_type = null, $reference_value = null, $additional_info = null, $code = null, $level = null, $from_date = null, $to_date = null, $with = null)
    {
        return $this->restLogsGetAsyncWithHttpInfo($page, $items_per_page, $integration, $identifier, $reference_type, $reference_value, $additional_info, $code, $level, $from_date, $to_date, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsGetAsyncWithHttpInfo
     *
     * Perform a search operation.
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $integration Filter that restricts the search result to log entries with custom integration key(s). (optional)
     * @param  int $identifier Filter that restricts the search result to log entries with custom identifier(s). (optional)
     * @param  string $reference_type Filter that restricts the search result to log entries with custom reference types. (optional)
     * @param  string $reference_value Filter that restricts the search result to log entries with custom reference values. (optional)
     * @param  string $additional_info Filter that restricts the search result to log entries that match an additional info. (optional)
     * @param  int $code Filter that restricts the search result to log entries with a custom code. (optional)
     * @param  int $level Filter that restricts the search result to log entries of a custom level. Available values are: &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;notice&#x27;, &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;critical&#x27;, &#x27;alert&#x27;, &#x27;emergency&#x27;. (optional)
     * @param  string $from_date Filter that restricts the search result to log entries created after this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $to_date Filter that restricts the search result to log entries created before this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;additionalInfo&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsGetAsyncWithHttpInfo($page = null, $items_per_page = null, $integration = null, $identifier = null, $reference_type = null, $reference_value = null, $additional_info = null, $code = null, $level = null, $from_date = null, $to_date = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restLogsGetRequest($page, $items_per_page, $integration, $identifier, $reference_type, $reference_value, $additional_info, $code, $level, $from_date, $to_date, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsGet'
     *
     * @param  int $page The page of results to search for. (optional)
     * @param  int $items_per_page The number of items to list per page. (optional)
     * @param  int $integration Filter that restricts the search result to log entries with custom integration key(s). (optional)
     * @param  int $identifier Filter that restricts the search result to log entries with custom identifier(s). (optional)
     * @param  string $reference_type Filter that restricts the search result to log entries with custom reference types. (optional)
     * @param  string $reference_value Filter that restricts the search result to log entries with custom reference values. (optional)
     * @param  string $additional_info Filter that restricts the search result to log entries that match an additional info. (optional)
     * @param  int $code Filter that restricts the search result to log entries with a custom code. (optional)
     * @param  int $level Filter that restricts the search result to log entries of a custom level. Available values are: &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;notice&#x27;, &#x27;warning&#x27;, &#x27;error&#x27;, &#x27;critical&#x27;, &#x27;alert&#x27;, &#x27;emergency&#x27;. (optional)
     * @param  string $from_date Filter that restricts the search result to log entries created after this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $to_date Filter that restricts the search result to log entries created before this date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with An array with child instances to be loaded. Valid instances are &#x27;additionalInfo&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsGetRequest($page = null, $items_per_page = null, $integration = null, $identifier = null, $reference_type = null, $reference_value = null, $additional_info = null, $code = null, $level = null, $from_date = null, $to_date = null, $with = null)
    {

        $resourcePath = '/rest/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($integration !== null) {
            $queryParams['integration'] = ObjectSerializer::toQueryValue($integration);
        }
        // query params
        if ($identifier !== null) {
            $queryParams['identifier'] = ObjectSerializer::toQueryValue($identifier);
        }
        // query params
        if ($reference_type !== null) {
            $queryParams['referenceType'] = ObjectSerializer::toQueryValue($reference_type);
        }
        // query params
        if ($reference_value !== null) {
            $queryParams['referenceValue'] = ObjectSerializer::toQueryValue($reference_value);
        }
        // query params
        if ($additional_info !== null) {
            $queryParams['additionalInfo'] = ObjectSerializer::toQueryValue($additional_info);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code);
        }
        // query params
        if ($level !== null) {
            $queryParams['level'] = ObjectSerializer::toQueryValue($level);
        }
        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date);
        }
        // query params
        if ($to_date !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($to_date);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsIdGet
     *
     * Get Log entry by ID.
     *
     * @param  int $id id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyLogModelsLog
     */
    public function restLogsIdGet($id)
    {
        list($response) = $this->restLogsIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation restLogsIdGetWithHttpInfo
     *
     * Get Log entry by ID.
     *
     * @param  int $id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyLogModelsLog, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsIdGetWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyLogModelsLog';
        $request = $this->restLogsIdGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyLogModelsLog',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsIdGetAsync
     *
     * Get Log entry by ID.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsIdGetAsync($id)
    {
        return $this->restLogsIdGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsIdGetAsyncWithHttpInfo
     *
     * Get Log entry by ID.
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsIdGetAsyncWithHttpInfo($id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyLogModelsLog';
        $request = $this->restLogsIdGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsIdGet'
     *
     * @param  int $id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsIdGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restLogsIdGet'
            );
        }

        $resourcePath = '/rest/logs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsIntegrationKeysGet
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restLogsIntegrationKeysGet()
    {
        list($response) = $this->restLogsIntegrationKeysGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restLogsIntegrationKeysGetWithHttpInfo
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsIntegrationKeysGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsIntegrationKeysGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsIntegrationKeysGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsIntegrationKeysGetAsync()
    {
        return $this->restLogsIntegrationKeysGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsIntegrationKeysGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsIntegrationKeysGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsIntegrationKeysGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsIntegrationKeysGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsIntegrationKeysGetRequest()
    {

        $resourcePath = '/rest/logs/integration_keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsPost
     *
     * Create a log entry.
     *
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restLogsPost($body = null)
    {
        list($response) = $this->restLogsPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation restLogsPostWithHttpInfo
     *
     * Create a log entry.
     *
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsPostWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsPostAsync
     *
     * Create a log entry.
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsPostAsync($body = null)
    {
        return $this->restLogsPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsPostAsyncWithHttpInfo
     *
     * Create a log entry.
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsPost'
     *
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsPostRequest($body = null)
    {

        $resourcePath = '/rest/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsReferenceTypesGet
     *
     * Get all registered reference types.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restLogsReferenceTypesGet()
    {
        list($response) = $this->restLogsReferenceTypesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restLogsReferenceTypesGetWithHttpInfo
     *
     * Get all registered reference types.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsReferenceTypesGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsReferenceTypesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsReferenceTypesGetAsync
     *
     * Get all registered reference types.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsReferenceTypesGetAsync()
    {
        return $this->restLogsReferenceTypesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsReferenceTypesGetAsyncWithHttpInfo
     *
     * Get all registered reference types.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsReferenceTypesGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsReferenceTypesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsReferenceTypesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsReferenceTypesGetRequest()
    {

        $resourcePath = '/rest/logs/reference_types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsSettingsGet
     *
     * Show config.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restLogsSettingsGet()
    {
        list($response) = $this->restLogsSettingsGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restLogsSettingsGetWithHttpInfo
     *
     * Show config.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsSettingsGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsSettingsGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsSettingsGetAsync
     *
     * Show config.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsSettingsGetAsync()
    {
        return $this->restLogsSettingsGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsSettingsGetAsyncWithHttpInfo
     *
     * Show config.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsSettingsGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsSettingsGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsSettingsGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsSettingsGetRequest()
    {

        $resourcePath = '/rest/logs/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restLogsSettingsPost
     *
     * Save config.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restLogsSettingsPost()
    {
        list($response) = $this->restLogsSettingsPostWithHttpInfo();
        return $response;
    }

    /**
     * Operation restLogsSettingsPostWithHttpInfo
     *
     * Save config.
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restLogsSettingsPostWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsSettingsPostRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restLogsSettingsPostAsync
     *
     * Save config.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsSettingsPostAsync()
    {
        return $this->restLogsSettingsPostAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restLogsSettingsPostAsyncWithHttpInfo
     *
     * Save config.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restLogsSettingsPostAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restLogsSettingsPostRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restLogsSettingsPost'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restLogsSettingsPostRequest()
    {

        $resourcePath = '/rest/logs/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
