<?php
/**
 * ItemApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\Item\ItemPaginated;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\ItemImage\ItemImage;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\SalesPrice\SalesPrice;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\Variation\VariationPaginated;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\VariationImage\VariationImage;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\VariationSalesPrice\VariationSalesPrice;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Model\Plenty\Modules\Item\Item\Item;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;

/**
 * ItemApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ItemApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    )
    {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }


    /**
     * Create request for operation 'restItemsItemIdGet'
     *
     * @param int $item_id (required)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsItemIdGetRequest($item_id, $lang = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdGet'
            );
        }

        $resourcePath = '/rest/items/{itemId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Operation restItemsItemIdGet
     *
     * Show an item
     *
     * @param int $item_id item_id (required)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     *
     * @return Item
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsItemIdGet($item_id, $lang = null)
    {
        list($response) = $this->restItemsItemIdGetWithHttpInfo($item_id, $lang);
        return $response;
    }

    /**
     * Operation restItemsItemIdGetWithHttpInfo
     *
     * Show an item
     *
     * @param int $item_id (required)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     *
     * @return array of Item, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsItemIdGetWithHttpInfo($item_id, $lang = null)
    {
        $returnType = Item::class;
        $request = $this->restItemsItemIdGetRequest($item_id, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemItemModelsItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }


    /**
     * Operation restItemsItemIdVariationsGet
     *
     * List variations of an item
     *
     * @param int $item_id item_id (required)
     * @param string $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#x27;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param bool $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param bool $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param string $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param string $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param string $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param bool $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param string $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param string $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return object
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function restItemsItemIdVariationsGet($item_id, $with = null, $lang = null, $page = null, $items_per_page = null, $is_main = null, $is_active = null, $barcode = null, $number_exact = null, $number_fuzzy = null, $is_bundle = null, $supplier_number = null, $manufacturer_id = null, $updated_between = null, $created_between = null, $related_updated_between = null)
    {
        list($response) = $this->restItemsItemIdVariationsGetWithHttpInfo($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between);
        return $response;
    }

    /**
     * Operation restItemsItemIdVariationsGetWithHttpInfo
     *
     * List variations of an item
     *
     * @param int $item_id (required)
     * @param string $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#x27;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param bool $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param bool $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param string $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param string $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param string $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param bool $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param string $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param string $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function restItemsItemIdVariationsGetWithHttpInfo($item_id, $with = null, $lang = null, $page = null, $items_per_page = null, $is_main = null, $is_active = null, $barcode = null, $number_exact = null, $number_fuzzy = null, $is_bundle = null, $supplier_number = null, $manufacturer_id = null, $updated_between = null, $created_between = null, $related_updated_between = null)
    {
        $returnType = VariationPaginated::class;
        $request = $this->restItemsItemIdVariationsGetRequest($item_id, $with, $lang, $page, $items_per_page, $is_main, $is_active, $barcode, $number_exact, $number_fuzzy, $is_bundle, $supplier_number, $manufacturer_id, $updated_between, $created_between, $related_updated_between);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Create request for operation 'restItemsItemIdVariationsGet'
     *
     * @param int $item_id (required)
     * @param string $with Includes the specified variation information in the results. The following parameters are available: &lt;ul&gt;&lt;li&gt;properties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationProperties&lt;/b&gt; &#x3D; The properties linked to the variation&lt;/li&gt;&lt;li&gt;variationBarcodes&lt;/b&gt; &#x3D; The barcode linked to the variation and the saved code&lt;/li&gt;&lt;li&gt;variationBundleComponents&lt;/b&gt; &#x3D; The bundle components of the variation and their quantities&lt;/li&gt;&lt;li&gt;variationComponentBundles&lt;/b&gt; &#x3D; The bundles that this variation is a component of&lt;/li&gt;&lt;li&gt;variationSalesPrices&lt;/b&gt; &#x3D; The sales prices linked to the variation and the saved price&lt;/li&gt;&lt;li&gt;marketItemNumbers&lt;/b&gt; &#x3D; The market ident number of the variation&lt;/li&gt;&lt;li&gt;variationCategories&lt;/b&gt; &#x3D; The categories linked to the variation&lt;/li&gt;&lt;li&gt;variationClients&lt;/b&gt; &#x3D; The clients (stores) for which the variation is activated&lt;/li&gt;&lt;li&gt;variationMarkets&lt;/b&gt; &#x3D; The markets for which the variation is activated &lt;/li&gt;&lt;li&gt;variationDefaultCategory&lt;/b&gt; &#x3D; The default category of the variation&lt;/li&gt;&lt;li&gt;variationSuppliers&lt;/b&gt; &#x3D; The supplier data associated with the variation&lt;/li&gt;&lt;li&gt;variationWarehouses&lt;/b&gt; &#x3D; The warehouse data associated with the variation&lt;/li&gt;&lt;li&gt;images&lt;/b&gt; &#x3D; The images linked to the variation&lt;/li&gt;&lt;li&gt;itemImages&lt;/b&gt; &#x3D; The images linked to the item&lt;/li&gt;&lt;li&gt;variationAttributeValues&lt;/b&gt; &#x3D; The attribute values of the variation&lt;/li&gt;&lt;li&gt;variationSkus&lt;/b&gt; &#x3D; The SKU data associated with the variation&lt;/li&gt;&lt;li&gt;variationAdditionalSkus&lt;/b&gt; &#x3D; The additional SKU data associated with the variation&lt;/li&gt;&lt;li&gt;unit&lt;/b&gt; &#x3D; The unit assigned to the variation&lt;/li&gt;&lt;li&gt;parent&lt;/b&gt; &#x3D; The main variation of the variation. Value is null if this variation is the item&#x27;s main variation.&lt;/li&gt;&lt;li&gt;item&lt;/b&gt; &#x3D; The item of the variation&lt;/li&gt;&lt;li&gt;stock&lt;/b&gt; &#x3D; The stock data of the variation&lt;/li&gt;&lt;/ul&gt; For example, specifying the parameters variationCategories and variationDefaultCategory will include the default category and all other categories the variations are linked to. More than one parameter should be separated by commas. (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param bool $is_main Filter restricts the list of results to variations that are main variations. (optional)
     * @param bool $is_active Filter restricts the list of results to variations that are active. (optional)
     * @param string $barcode Filter restricts the list of results to variations with the specified barcode. A barcode must be specified. (optional)
     * @param string $number_exact Filter restricts the list of results to the variation with the variation number specified. (optional)
     * @param string $number_fuzzy Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312. (optional)
     * @param bool $is_bundle Filter restricts the list of results to variations to which variations were added to create a bundle. (optional)
     * @param string $supplier_number Filter restricts the list of results to variations with the specified supplier number. A supplier number must be specified. (optional)
     * @param int $manufacturer_id Filter restricts the list of results to variations with the specified manufacturer ID. (optional)
     * @param string $updated_between Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $created_between Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $related_updated_between Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsItemIdVariationsGetRequest($item_id, $with = null, $lang = null, $page = null, $items_per_page = null, $is_main = null, $is_active = null, $barcode = null, $number_exact = null, $number_fuzzy = null, $is_bundle = null, $supplier_number = null, $manufacturer_id = null, $updated_between = null, $created_between = null, $related_updated_between = null)
    {
        // verify the required parameter 'item_id' is set
        if ($item_id === null || (is_array($item_id) && count($item_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_id when calling restItemsItemIdVariationsGet'
            );
        }

        $resourcePath = '/rest/items/{itemId}/variations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($is_main !== null) {
            $queryParams['isMain'] = ObjectSerializer::toQueryValue($is_main);
        }
        // query params
        if ($is_active !== null) {
            $queryParams['isActive'] = ObjectSerializer::toQueryValue($is_active);
        }
        // query params
        if ($barcode !== null) {
            $queryParams['barcode'] = ObjectSerializer::toQueryValue($barcode);
        }
        // query params
        if ($number_exact !== null) {
            $queryParams['numberExact'] = ObjectSerializer::toQueryValue($number_exact);
        }
        // query params
        if ($number_fuzzy !== null) {
            $queryParams['numberFuzzy'] = ObjectSerializer::toQueryValue($number_fuzzy);
        }
        // query params
        if ($is_bundle !== null) {
            $queryParams['isBundle'] = ObjectSerializer::toQueryValue($is_bundle);
        }
        // query params
        if ($supplier_number !== null) {
            $queryParams['supplierNumber'] = ObjectSerializer::toQueryValue($supplier_number);
        }
        // query params
        if ($manufacturer_id !== null) {
            $queryParams['manufacturerId'] = ObjectSerializer::toQueryValue($manufacturer_id);
        }
        // query params
        if ($updated_between !== null) {
            $queryParams['updatedBetween'] = ObjectSerializer::toQueryValue($updated_between);
        }
        // query params
        if ($created_between !== null) {
            $queryParams['createdBetween'] = ObjectSerializer::toQueryValue($created_between);
        }
        // query params
        if ($related_updated_between !== null) {
            $queryParams['relatedUpdatedBetween'] = ObjectSerializer::toQueryValue($related_updated_between);
        }

        // path params
        if ($item_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemId' . '}',
                ObjectSerializer::toPathValue($item_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Operation restItemsGet
     *
     * Search item
     *
     * @param string $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param string $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param string $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param int $tag_id Filter restricts the list of results to items with the specified tagId. More than one ID should be separated by commas. (optional)
     * @param int $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param int $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param string $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return ItemPaginated
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function restItemsGet($with = null, $lang = null, $page = null, $items_per_page = null, $name = null, $manufacturer_id = null, $tag_id = null, $flag_one = null, $flag_two = null, $updated_between = null, $variation_updated_between = null, $variation_related_updated_between = null)
    {
        list($response) = $this->restItemsGetWithHttpInfo($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $tag_id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between);
        return $response;
    }

    /**
     * Operation restItemsGetWithHttpInfo
     *
     * Search item
     *
     * @param string $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param string $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param string $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param int $tag_id Filter restricts the list of results to items with the specified tagId. More than one ID should be separated by commas. (optional)
     * @param int $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param int $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param string $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return ItemPaginated, HTTP status code, HTTP response headers (array of strings)
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     */
    public function restItemsGetWithHttpInfo($with = null, $lang = null, $page = null, $items_per_page = null, $name = null, $manufacturer_id = null, $tag_id = null, $flag_one = null, $flag_two = null, $updated_between = null, $variation_updated_between = null, $variation_related_updated_between = null)
    {
        $returnType = ItemPaginated::class;
        $request = $this->restItemsGetRequest($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $tag_id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsGetAsync
     *
     * Search item
     *
     * @param string $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param string $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param string $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param int $tag_id Filter restricts the list of results to items with the specified tagId. More than one ID should be separated by commas. (optional)
     * @param int $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param int $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param string $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsGetAsync($with = null, $lang = null, $page = null, $items_per_page = null, $name = null, $manufacturer_id = null, $tag_id = null, $flag_one = null, $flag_two = null, $updated_between = null, $variation_updated_between = null, $variation_related_updated_between = null)
    {
        return $this->restItemsGetAsyncWithHttpInfo($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $tag_id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsGetAsyncWithHttpInfo
     *
     * Search item
     *
     * @param string $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param string $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param string $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param int $tag_id Filter restricts the list of results to items with the specified tagId. More than one ID should be separated by commas. (optional)
     * @param int $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param int $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param string $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsGetAsyncWithHttpInfo($with = null, $lang = null, $page = null, $items_per_page = null, $name = null, $manufacturer_id = null, $tag_id = null, $flag_one = null, $flag_two = null, $updated_between = null, $variation_updated_between = null, $variation_related_updated_between = null)
    {
        $returnType = ItemPaginated::class;
        $request = $this->restItemsGetRequest($with, $lang, $page, $items_per_page, $name, $manufacturer_id, $tag_id, $flag_one, $flag_two, $updated_between, $variation_updated_between, $variation_related_updated_between);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsGet'
     *
     * @param string $with Includes the specified variation information in the results. The following parameters are available: itemProperties, itemCrossSelling, variations, itemImages, itemShippingProfiles, ebayTitles (optional)
     * @param string $lang The &lt;a href&#x3D;&#x27;https://developers.plentymarkets.com/rest-doc/introduction#countries&#x27; target&#x3D;&#x27;_blank&#x27;&gt;language&lt;/a&gt; of the variation information. (optional)
     * @param int $page Limits the results to a specific page. The page number must be specified. (optional)
     * @param int $items_per_page Limits the number of results listed per page to a specific number. The number of variations to be listed per page must be specified. (optional)
     * @param string $name Filter restricts the list of results to items with the specified item name. An item name must be specified. (optional)
     * @param string $manufacturer_id Filter restricts the list of results to items with the specified manufacturerId. (optional)
     * @param int $tag_id Filter restricts the list of results to items with the specified tagId. More than one ID should be separated by commas. (optional)
     * @param int $flag_one Filter restricts the list of results to items with the specified flagOne. (optional)
     * @param int $flag_two Filter restricts the list of results to items with the specified flagTwo. (optional)
     * @param string $updated_between Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_updated_between Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported. (optional)
     * @param string $variation_related_updated_between Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats. (optional)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsGetRequest($with = null, $lang = null, $page = null, $items_per_page = null, $name = null, $manufacturer_id = null, $tag_id = null, $flag_one = null, $flag_two = null, $updated_between = null, $variation_updated_between = null, $variation_related_updated_between = null)
    {

        $resourcePath = '/rest/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($manufacturer_id !== null) {
            $queryParams['manufacturerId'] = ObjectSerializer::toQueryValue($manufacturer_id);
        }
        // query params
        if ($tag_id !== null) {
            $queryParams['tagId'] = ObjectSerializer::toQueryValue($tag_id);
        }
        // query params
        if ($flag_one !== null) {
            $queryParams['flagOne'] = ObjectSerializer::toQueryValue($flag_one);
        }
        // query params
        if ($flag_two !== null) {
            $queryParams['flagTwo'] = ObjectSerializer::toQueryValue($flag_two);
        }
        // query params
        if ($updated_between !== null) {
            $queryParams['updatedBetween'] = ObjectSerializer::toQueryValue($updated_between);
        }
        // query params
        if ($variation_updated_between !== null) {
            $queryParams['variationUpdatedBetween'] = ObjectSerializer::toQueryValue($variation_updated_between);
        }
        // query params
        if ($variation_related_updated_between !== null) {
            $queryParams['variationRelatedUpdatedBetween'] = ObjectSerializer::toQueryValue($variation_related_updated_between);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGet
     *
     * List sales prices of a variation
     *
     * @param int $id id (required)
     * @param int $variation_id variation_id (required)
     *
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationSalesPriceModelsVariationSalesPrice[]
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGet($id, $variation_id)
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo($id, $variation_id);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo
     *
     * List sales prices of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationSalesPriceModelsVariationSalesPrice[], HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetWithHttpInfo($id, $variation_id)
    {
        $returnType = VariationSalesPrice::class;
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetRequest($id, $variation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationSalesPriceModelsVariationSalesPrice[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetAsync
     *
     * List sales prices of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetAsync($id, $variation_id)
    {
        return $this->restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo($id, $variation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo
     *
     * List sales prices of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdVariationsVariationIdVariationSalesPricesGetAsyncWithHttpInfo($id, $variation_id)
    {
        $returnType = VariationSalesPrice::class;
        $request = $this->restItemsIdVariationsVariationIdVariationSalesPricesGetRequest($id, $variation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationSalesPricesGet'
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsIdVariationsVariationIdVariationSalesPricesGetRequest($id, $variation_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationSalesPricesGet'
            );
        }
        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationSalesPricesGet'
            );
        }

        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_sales_prices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGet
     *
     * List image links of a variation
     *
     * @param int $id id (required)
     * @param int $variation_id variation_id (required)
     * @param string $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationImageModelsVariationImage
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdVariationsVariationIdVariationImagesGet($id, $variation_id, $updated_at = null)
    {
        list($response) = $this->restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo($id, $variation_id, $updated_at);
        return $response;
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo
     *
     * List image links of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     * @param string $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationImageModelsVariationImage, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetWithHttpInfo($id, $variation_id, $updated_at = null)
    {
        $returnType = VariationImage::class;
        $request = $this->restItemsIdVariationsVariationIdVariationImagesGetRequest($id, $variation_id, $updated_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesItemVariationImageModelsVariationImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetAsync
     *
     * List image links of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     * @param string $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetAsync($id, $variation_id, $updated_at = null)
    {
        return $this->restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo($id, $variation_id, $updated_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo
     *
     * List image links of a variation
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     * @param string $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdVariationsVariationIdVariationImagesGetAsyncWithHttpInfo($id, $variation_id, $updated_at = null)
    {
        $returnType = VariationImage::class;
        $request = $this->restItemsIdVariationsVariationIdVariationImagesGetRequest($id, $variation_id, $updated_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdVariationsVariationIdVariationImagesGet'
     *
     * @param int $id (required)
     * @param int $variation_id (required)
     * @param string $updated_at Filter restricts the list of results to variation images updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsIdVariationsVariationIdVariationImagesGetRequest($id, $variation_id, $updated_at = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdVariationsVariationIdVariationImagesGet'
            );
        }
        // verify the required parameter 'variation_id' is set
        if ($variation_id === null || (is_array($variation_id) && count($variation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variation_id when calling restItemsIdVariationsVariationIdVariationImagesGet'
            );
        }

        $resourcePath = '/rest/items/{id}/variations/{variationId}/variation_images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = ObjectSerializer::toQueryValue($updated_at);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($variation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'variationId' . '}',
                ObjectSerializer::toPathValue($variation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Operation restItemsIdImagesGet
     *
     * List images of an item
     *
     * @param int $id id (required)
     * @param string $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return ItemImage[]
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdImagesGet($id, $updated_at = null)
    {
        list($response) = $this->restItemsIdImagesGetWithHttpInfo($id, $updated_at);
        return $response;
    }

    /**
     * Operation restItemsIdImagesGetWithHttpInfo
     *
     * List images of an item
     *
     * @param int $id (required)
     * @param string $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return array of ItemImage, HTTP status code, HTTP response headers (array of strings)
     * @throws \InvalidArgumentException
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     */
    public function restItemsIdImagesGetWithHttpInfo($id, $updated_at = null)
    {
        $returnType = ItemImage::class;
        $request = $this->restItemsIdImagesGetRequest($id, $updated_at);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        ItemImage::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restItemsIdImagesGetAsync
     *
     * List images of an item
     *
     * @param int $id (required)
     * @param string $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdImagesGetAsync($id, $updated_at = null)
    {
        return $this->restItemsIdImagesGetAsyncWithHttpInfo($id, $updated_at)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restItemsIdImagesGetAsyncWithHttpInfo
     *
     * List images of an item
     *
     * @param int $id (required)
     * @param string $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @throws \InvalidArgumentException
     */
    public function restItemsIdImagesGetAsyncWithHttpInfo($id, $updated_at = null)
    {
        $returnType = ItemImage::class;
        $request = $this->restItemsIdImagesGetRequest($id, $updated_at);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restItemsIdImagesGet'
     *
     * @param int $id (required)
     * @param string $updated_at Filter restricts the list of results to items updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported. (optional)
     *
     * @return \GuzzleHttp\Psr7\Request
     * @throws \InvalidArgumentException
     */
    protected function restItemsIdImagesGetRequest($id, $updated_at = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restItemsIdImagesGet'
            );
        }

        $resourcePath = '/rest/items/{id}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($updated_at !== null) {
            $queryParams['updatedAt'] = ObjectSerializer::toQueryValue($updated_at);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }


    /**
     * Create http client option
     *
     * @return array of http client options
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}