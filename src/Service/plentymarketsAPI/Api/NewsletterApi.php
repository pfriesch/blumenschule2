<?php
/**
 * NewsletterApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;

/**
 * NewsletterApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class NewsletterApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restNewslettersDelete
     *
     * Delete entries
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]
     */
    public function restNewslettersDelete()
    {
        list($response) = $this->restNewslettersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersDeleteWithHttpInfo
     *
     * Delete entries
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDeleteAsync
     *
     * Delete entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDeleteAsync()
    {
        return $this->restNewslettersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDeleteAsyncWithHttpInfo
     *
     * Delete entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPost
     *
     * @param  int $contact_id contact_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restNewslettersDoubleOptInContactIdPost($contact_id)
    {
        list($response) = $this->restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostWithHttpInfo
     *
     * @param  int $contact_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsync
     *
     * 
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsync($contact_id)
    {
        return $this->restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDoubleOptInContactIdPost'
     *
     * @param  int $contact_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersDoubleOptInContactIdPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restNewslettersDoubleOptInContactIdPost'
            );
        }

        $resourcePath = '/rest/newsletters/double_opt_in/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdDelete
     *
     * Delete an entry
     *
     * @param  int $entry_id entry_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry
     */
    public function restNewslettersEntryIdDelete($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdDeleteWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdDeleteWithHttpInfo
     *
     * Delete an entry
     *
     * @param  int $entry_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdDeleteWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsync
     *
     * Delete an entry
     *
     * @param  int $entry_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsync($entry_id)
    {
        return $this->restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete an entry
     *
     * @param  int $entry_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdDelete'
     *
     * @param  int $entry_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdDeleteRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdGet
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry
     */
    public function restNewslettersEntryIdGet($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdGetWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdGetWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdGetWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdGetAsync
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdGetAsync($entry_id)
    {
        return $this->restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdGetAsyncWithHttpInfo
     *
     * List details of an entry
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdGet'
     *
     * @param  int $entry_id The ID of the newsletter entry. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdGetRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdPut
     *
     * Update an entry
     *
     * @param  int $entry_id entry_id (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry
     */
    public function restNewslettersEntryIdPut($entry_id, $subject = null, $body = null, $kind = null)
    {
        list($response) = $this->restNewslettersEntryIdPutWithHttpInfo($entry_id, $subject, $body, $kind);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdPutWithHttpInfo
     *
     * Update an entry
     *
     * @param  int $entry_id (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersEntryIdPutWithHttpInfo($entry_id, $subject = null, $body = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $subject, $body, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdPutAsync
     *
     * Update an entry
     *
     * @param  int $entry_id (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdPutAsync($entry_id, $subject = null, $body = null, $kind = null)
    {
        return $this->restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $subject, $body, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdPutAsyncWithHttpInfo
     *
     * Update an entry
     *
     * @param  int $entry_id (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $subject = null, $body = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $subject, $body, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdPut'
     *
     * @param  int $entry_id (required)
     * @param  string $subject The subject of the entry (optional)
     * @param  string $body The body of the entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersEntryIdPutRequest($entry_id, $subject = null, $body = null, $kind = null)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($body !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body);
        }
        // query params
        if ($kind !== null) {
            $queryParams['kind'] = ObjectSerializer::toQueryValue($kind);
        }

        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersDelete
     *
     * Delete folders
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]
     */
    public function restNewslettersFoldersDelete()
    {
        list($response) = $this->restNewslettersFoldersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersFoldersDeleteWithHttpInfo
     *
     * Delete folders
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]';
        $request = $this->restNewslettersFoldersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersDeleteAsync
     *
     * Delete folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsync()
    {
        return $this->restNewslettersFoldersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersDeleteAsyncWithHttpInfo
     *
     * Delete folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]';
        $request = $this->restNewslettersFoldersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDelete
     *
     * Delete a folder
     *
     * @param  int $folder_id folder_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder
     */
    public function restNewslettersFoldersFolderIdDelete($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteWithHttpInfo
     *
     * Delete a folder
     *
     * @param  int $folder_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsync
     *
     * Delete a folder
     *
     * @param  int $folder_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo
     *
     * Delete a folder
     *
     * @param  int $folder_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdDelete'
     *
     * @param  int $folder_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdDeleteRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGet
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder
     */
    public function restNewslettersFoldersFolderIdGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsync
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsyncWithHttpInfo
     *
     * List details of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPut
     *
     * Update a folder
     *
     * @param  int $folder_id folder_id (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder
     */
    public function restNewslettersFoldersFolderIdPut($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        list($response) = $this->restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutWithHttpInfo
     *
     * Update a folder
     *
     * @param  int $folder_id (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsync
     *
     * Update a folder
     *
     * @param  int $folder_id (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsync($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        return $this->restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsyncWithHttpInfo
     *
     * Update a folder
     *
     * @param  int $folder_id (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdPut'
     *
     * @param  int $folder_id (required)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdPutRequest($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($position !== null) {
            $queryParams['position'] = ObjectSerializer::toQueryValue($position);
        }
        // query params
        if ($client_ids !== null) {
            $queryParams['clientIds'] = ObjectSerializer::toQueryValue($client_ids);
        }
        // query params
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = ObjectSerializer::toQueryValue($is_deletable);
        }
        // query params
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = ObjectSerializer::toQueryValue($is_selectable);
        }

        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGet
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]
     */
    public function restNewslettersFoldersFolderIdRecipientsGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsync
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdRecipientsGet'
     *
     * @param  int $folder_id The ID of the newsletter folder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdRecipientsGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersGet
     *
     * List newsletter folders
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]
     */
    public function restNewslettersFoldersGet()
    {
        list($response) = $this->restNewslettersFoldersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersFoldersGetWithHttpInfo
     *
     * List newsletter folders
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersGetAsync
     *
     * List newsletter folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersGetAsync()
    {
        return $this->restNewslettersFoldersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersGetAsyncWithHttpInfo
     *
     * List newsletter folders
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersGetRequest()
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersPost
     *
     * Create a folder
     *
     * @param  object $body body (optional)
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder
     */
    public function restNewslettersFoldersPost($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        list($response) = $this->restNewslettersFoldersPostWithHttpInfo($body, $id, $name, $position, $is_deletable, $is_selectable);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersPostWithHttpInfo
     *
     * Create a folder
     *
     * @param  object $body (optional)
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersFoldersPostWithHttpInfo($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersPostRequest($body, $id, $name, $position, $is_deletable, $is_selectable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersPostAsync
     *
     * Create a folder
     *
     * @param  object $body (optional)
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersPostAsync($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        return $this->restNewslettersFoldersPostAsyncWithHttpInfo($body, $id, $name, $position, $is_deletable, $is_selectable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersPostAsyncWithHttpInfo
     *
     * Create a folder
     *
     * @param  object $body (optional)
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersFoldersPostAsyncWithHttpInfo($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersPostRequest($body, $id, $name, $position, $is_deletable, $is_selectable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersPost'
     *
     * @param  object $body (optional)
     * @param  int $id The ID of the newsletter folder (optional)
     * @param  string $name The name of the newsletter folder (optional)
     * @param  int $position The position of the newsletter folder (optional)
     * @param  bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param  bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersFoldersPostRequest($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($position !== null) {
            $queryParams['position'] = ObjectSerializer::toQueryValue($position);
        }
        // query params
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = ObjectSerializer::toQueryValue($is_deletable);
        }
        // query params
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = ObjectSerializer::toQueryValue($is_selectable);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersGet
     *
     * List newsletter entries
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]
     */
    public function restNewslettersGet()
    {
        list($response) = $this->restNewslettersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersGetWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersGetAsync
     *
     * List newsletter entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersGetAsync()
    {
        return $this->restNewslettersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersGetAsyncWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersGetRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersListRecipientsGet
     *
     * List recipients
     *
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restNewslettersListRecipientsGet($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        list($response) = $this->restNewslettersListRecipientsGetWithHttpInfo($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);
        return $response;
    }

    /**
     * Operation restNewslettersListRecipientsGetWithHttpInfo
     *
     * List recipients
     *
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersListRecipientsGetWithHttpInfo($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restNewslettersListRecipientsGetRequest($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersListRecipientsGetAsync
     *
     * List recipients
     *
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsync($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        return $this->restNewslettersListRecipientsGetAsyncWithHttpInfo($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersListRecipientsGetAsyncWithHttpInfo
     *
     * List recipients
     *
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersListRecipientsGetAsyncWithHttpInfo($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restNewslettersListRecipientsGetRequest($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersListRecipientsGet'
     *
     * @param  int $columns Filter that restricts the search result to specific columns (optional)
     * @param  int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param  int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param  int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param  bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param  int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersListRecipientsGetRequest($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {

        $resourcePath = '/rest/newsletters/list_recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($columns !== null) {
            $queryParams['columns'] = ObjectSerializer::toQueryValue($columns);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($is_confirmed !== null) {
            $queryParams['isConfirmed'] = ObjectSerializer::toQueryValue($is_confirmed);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersPost
     *
     * Create an entry
     *
     * @param  object $body body (optional)
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body2 The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry
     */
    public function restNewslettersPost($body = null, $subject = null, $body2 = null, $kind = null)
    {
        list($response) = $this->restNewslettersPostWithHttpInfo($body, $subject, $body2, $kind);
        return $response;
    }

    /**
     * Operation restNewslettersPostWithHttpInfo
     *
     * Create an entry
     *
     * @param  object $body (optional)
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body2 The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersPostWithHttpInfo($body = null, $subject = null, $body2 = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersPostRequest($body, $subject, $body2, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersPostAsync
     *
     * Create an entry
     *
     * @param  object $body (optional)
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body2 The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersPostAsync($body = null, $subject = null, $body2 = null, $kind = null)
    {
        return $this->restNewslettersPostAsyncWithHttpInfo($body, $subject, $body2, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersPostAsyncWithHttpInfo
     *
     * Create an entry
     *
     * @param  object $body (optional)
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body2 The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersPostAsyncWithHttpInfo($body = null, $subject = null, $body2 = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersPostRequest($body, $subject, $body2, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersPost'
     *
     * @param  object $body (optional)
     * @param  string $subject The subject of the newsletter entry (optional)
     * @param  string $body2 The body of the newsletter entry (optional)
     * @param  string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersPostRequest($body = null, $subject = null, $body2 = null, $kind = null)
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($body2 !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body2);
        }
        // query params
        if ($kind !== null) {
            $queryParams['kind'] = ObjectSerializer::toQueryValue($kind);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsDelete
     *
     * Delete recipients
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]
     */
    public function restNewslettersRecipientsDelete()
    {
        list($response) = $this->restNewslettersRecipientsDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsDeleteWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsync
     *
     * Delete recipients
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsync()
    {
        return $this->restNewslettersRecipientsDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsyncWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsDelete'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsGet
     *
     * List recipients of a folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]
     */
    public function restNewslettersRecipientsGet($email = null, $folder_id = null, $recipient_id = null)
    {
        list($response) = $this->restNewslettersRecipientsGetWithHttpInfo($email, $folder_id, $recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsGetWithHttpInfo
     *
     * List recipients of a folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsGetWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsGetAsync
     *
     * List recipients of a folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsGetAsync($email = null, $folder_id = null, $recipient_id = null)
    {
        return $this->restNewslettersRecipientsGetAsyncWithHttpInfo($email, $folder_id, $recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsGetAsyncWithHttpInfo
     *
     * List recipients of a folder
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsGetAsyncWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsGet'
     *
     * @param  string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param  int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param  int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsGetRequest($email = null, $folder_id = null, $recipient_id = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($recipient_id !== null) {
            $queryParams['recipientId'] = ObjectSerializer::toQueryValue($recipient_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsPost
     *
     * Create a recipient
     *
     * @param  object $body body (optional)
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]
     */
    public function restNewslettersRecipientsPost($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        list($response) = $this->restNewslettersRecipientsPostWithHttpInfo($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsPostWithHttpInfo
     *
     * Create a recipient
     *
     * @param  object $body (optional)
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsPostWithHttpInfo($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsPostAsync
     *
     * Create a recipient
     *
     * @param  object $body (optional)
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsPostAsync($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        return $this->restNewslettersRecipientsPostAsyncWithHttpInfo($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsPostAsyncWithHttpInfo
     *
     * Create a recipient
     *
     * @param  object $body (optional)
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsPostAsyncWithHttpInfo($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsPost'
     *
     * @param  object $body (optional)
     * @param  string $email The email address of the recipient (optional)
     * @param  string $first_name The first name of the recipient (optional)
     * @param  string $last_name The last name of the recipient (optional)
     * @param  int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param  bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsPostRequest($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['firstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($last_name !== null) {
            $queryParams['lastName'] = ObjectSerializer::toQueryValue($last_name);
        }
        // query params
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = ObjectSerializer::toQueryValue($folder_ids);
        }
        // query params
        if ($is_frontend !== null) {
            $queryParams['isFrontend'] = ObjectSerializer::toQueryValue($is_frontend);
        }
        // query params
        if ($ignore_visibility !== null) {
            $queryParams['ignoreVisibility'] = ObjectSerializer::toQueryValue($ignore_visibility);
        }
        // query params
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = ObjectSerializer::toQueryValue($ip_address);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDelete
     *
     * Delete a recipient
     *
     * @param  int $recipient_id recipient_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient
     */
    public function restNewslettersRecipientsRecipientIdDelete($recipient_id)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteWithHttpInfo
     *
     * Delete a recipient
     *
     * @param  int $recipient_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsync
     *
     * Delete a recipient
     *
     * @param  int $recipient_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsync($recipient_id)
    {
        return $this->restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo
     *
     * Delete a recipient
     *
     * @param  int $recipient_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdDelete'
     *
     * @param  int $recipient_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGet
     *
     * List a recipient
     *
     * @param  int $recipient_id recipient_id (required)
     * @param  int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient
     */
    public function restNewslettersRecipientsRecipientIdGet($recipient_id, $recipients_id = null)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id, $recipients_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetWithHttpInfo
     *
     * List a recipient
     *
     * @param  int $recipient_id (required)
     * @param  int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id, $recipients_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsync
     *
     * List a recipient
     *
     * @param  int $recipient_id (required)
     * @param  int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsync($recipient_id, $recipients_id = null)
    {
        return $this->restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id, $recipients_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo
     *
     * List a recipient
     *
     * @param  int $recipient_id (required)
     * @param  int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id, $recipients_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdGet'
     *
     * @param  int $recipient_id (required)
     * @param  int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($recipients_id !== null) {
            $queryParams['recipientsId'] = ObjectSerializer::toQueryValue($recipients_id);
        }

        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPut
     *
     * Update a recipient
     *
     * @param  int $recipient_id recipient_id (required)
     * @param  object $body body (optional)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient
     */
    public function restNewslettersRecipientsRecipientIdPut($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutWithHttpInfo
     *
     * Update a recipient
     *
     * @param  int $recipient_id (required)
     * @param  object $body (optional)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     */
    public function restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsync
     *
     * Update a recipient
     *
     * @param  int $recipient_id (required)
     * @param  object $body (optional)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsync($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        return $this->restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo
     *
     * Update a recipient
     *
     * @param  int $recipient_id (required)
     * @param  object $body (optional)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdPut'
     *
     * @param  int $recipient_id (required)
     * @param  object $body (optional)
     * @param  string $email The email address of the newsletter recipient (optional)
     * @param  string $first_name The first name of the newsletter recipient (optional)
     * @param  string $last_name The last name of the newsletter recipient (optional)
     * @param  int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param  int $folder_id The ID of the newsletter folder. (optional)
     * @param  string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param  string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param  string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['firstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($last_name !== null) {
            $queryParams['lastName'] = ObjectSerializer::toQueryValue($last_name);
        }
        // query params
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = ObjectSerializer::toQueryValue($folder_ids);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = ObjectSerializer::toQueryValue($ip_address);
        }
        // query params
        if ($birthday !== null) {
            $queryParams['birthday'] = ObjectSerializer::toQueryValue($birthday);
        }
        // query params
        if ($gender !== null) {
            $queryParams['gender'] = ObjectSerializer::toQueryValue($gender);
        }

        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
