<?php
/**
 * NewsletterApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder;
use BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use function GuzzleHttp\Psr7\build_query;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;
use InvalidArgumentException;
use RuntimeException;
use stdClass;

/**
 * NewsletterApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class NewsletterApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration $config
     * @param HeaderSelector $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    )
    {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restNewslettersDelete
     *
     * Delete entries
     *
     *
     * @return PlentyModulesAccountNewsletterModelsEntry[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersDelete()
    {
        list($response) = $this->restNewslettersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersDeleteWithHttpInfo
     *
     * Delete entries
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDeleteAsync
     *
     * Delete entries
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersDeleteAsync()
    {
        return $this->restNewslettersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDeleteAsyncWithHttpInfo
     *
     * Delete entries
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDelete'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPost
     *
     * @param int $contact_id contact_id (required)
     *
     * @return PlentyDataSimpleRestResponse
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersDoubleOptInContactIdPost($contact_id)
    {
        list($response) = $this->restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id);
        return $response;
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostWithHttpInfo
     *
     * @param int $contact_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersDoubleOptInContactIdPostWithHttpInfo($contact_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsync
     *
     *
     *
     * @param int $contact_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersDoubleOptInContactIdPostAsync($contact_id)
    {
        return $this->restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo
     *
     *
     *
     * @param int $contact_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersDoubleOptInContactIdPostAsyncWithHttpInfo($contact_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restNewslettersDoubleOptInContactIdPostRequest($contact_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersDoubleOptInContactIdPost'
     *
     * @param int $contact_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersDoubleOptInContactIdPostRequest($contact_id)
    {
        // verify the required parameter 'contact_id' is set
        if ($contact_id === null || (is_array($contact_id) && count($contact_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contact_id when calling restNewslettersDoubleOptInContactIdPost'
            );
        }

        $resourcePath = '/rest/newsletters/double_opt_in/{contactId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($contact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'contactId' . '}',
                ObjectSerializer::toPathValue($contact_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdDelete
     *
     * Delete an entry
     *
     * @param int $entry_id entry_id (required)
     *
     * @return PlentyModulesAccountNewsletterModelsEntry
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdDelete($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdDeleteWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdDeleteWithHttpInfo
     *
     * Delete an entry
     *
     * @param int $entry_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdDeleteWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsync
     *
     * Delete an entry
     *
     * @param int $entry_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdDeleteAsync($entry_id)
    {
        return $this->restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete an entry
     *
     * @param int $entry_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdDeleteAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdDeleteRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdDelete'
     *
     * @param int $entry_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersEntryIdDeleteRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdGet
     *
     * List details of an entry
     *
     * @param int $entry_id The ID of the newsletter entry. (required)
     *
     * @return PlentyModulesAccountNewsletterModelsEntry
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdGet($entry_id)
    {
        list($response) = $this->restNewslettersEntryIdGetWithHttpInfo($entry_id);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdGetWithHttpInfo
     *
     * List details of an entry
     *
     * @param int $entry_id The ID of the newsletter entry. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdGetWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdGetAsync
     *
     * List details of an entry
     *
     * @param int $entry_id The ID of the newsletter entry. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdGetAsync($entry_id)
    {
        return $this->restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdGetAsyncWithHttpInfo
     *
     * List details of an entry
     *
     * @param int $entry_id The ID of the newsletter entry. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdGetAsyncWithHttpInfo($entry_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdGetRequest($entry_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdGet'
     *
     * @param int $entry_id The ID of the newsletter entry. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersEntryIdGetRequest($entry_id)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersEntryIdPut
     *
     * Update an entry
     *
     * @param int $entry_id entry_id (required)
     * @param string $subject The subject of the entry (optional)
     * @param string $body The body of the entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsEntry
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdPut($entry_id, $subject = null, $body = null, $kind = null)
    {
        list($response) = $this->restNewslettersEntryIdPutWithHttpInfo($entry_id, $subject, $body, $kind);
        return $response;
    }

    /**
     * Operation restNewslettersEntryIdPutWithHttpInfo
     *
     * Update an entry
     *
     * @param int $entry_id (required)
     * @param string $subject The subject of the entry (optional)
     * @param string $body The body of the entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersEntryIdPutWithHttpInfo($entry_id, $subject = null, $body = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $subject, $body, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersEntryIdPutAsync
     *
     * Update an entry
     *
     * @param int $entry_id (required)
     * @param string $subject The subject of the entry (optional)
     * @param string $body The body of the entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdPutAsync($entry_id, $subject = null, $body = null, $kind = null)
    {
        return $this->restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $subject, $body, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersEntryIdPutAsyncWithHttpInfo
     *
     * Update an entry
     *
     * @param int $entry_id (required)
     * @param string $subject The subject of the entry (optional)
     * @param string $body The body of the entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersEntryIdPutAsyncWithHttpInfo($entry_id, $subject = null, $body = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersEntryIdPutRequest($entry_id, $subject, $body, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersEntryIdPut'
     *
     * @param int $entry_id (required)
     * @param string $subject The subject of the entry (optional)
     * @param string $body The body of the entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersEntryIdPutRequest($entry_id, $subject = null, $body = null, $kind = null)
    {
        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $entry_id when calling restNewslettersEntryIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($body !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body);
        }
        // query params
        if ($kind !== null) {
            $queryParams['kind'] = ObjectSerializer::toQueryValue($kind);
        }

        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersDelete
     *
     * Delete folders
     *
     *
     * @return PlentyModulesAccountNewsletterModelsFolder[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersDelete()
    {
        list($response) = $this->restNewslettersFoldersDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersFoldersDeleteWithHttpInfo
     *
     * Delete folders
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]';
        $request = $this->restNewslettersFoldersDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersDeleteAsync
     *
     * Delete folders
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersDeleteAsync()
    {
        return $this->restNewslettersFoldersDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersDeleteAsyncWithHttpInfo
     *
     * Delete folders
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder[]';
        $request = $this->restNewslettersFoldersDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersDelete'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDelete
     *
     * Delete a folder
     *
     * @param int $folder_id folder_id (required)
     *
     * @return PlentyModulesAccountNewsletterModelsFolder
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdDelete($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteWithHttpInfo
     *
     * Delete a folder
     *
     * @param int $folder_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdDeleteWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsync
     *
     * Delete a folder
     *
     * @param int $folder_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdDeleteAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo
     *
     * Delete a folder
     *
     * @param int $folder_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdDeleteAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdDeleteRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdDelete'
     *
     * @param int $folder_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersFolderIdDeleteRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGet
     *
     * List details of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PlentyModulesAccountNewsletterModelsFolder
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetWithHttpInfo
     *
     * List details of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdGetWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsync
     *
     * List details of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdGetAsyncWithHttpInfo
     *
     * List details of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdGet'
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersFolderIdGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPut
     *
     * Update a folder
     *
     * @param int $folder_id folder_id (required)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsFolder
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdPut($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        list($response) = $this->restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutWithHttpInfo
     *
     * Update a folder
     *
     * @param int $folder_id (required)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdPutWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsync
     *
     * Update a folder
     *
     * @param int $folder_id (required)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdPutAsync($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        return $this->restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdPutAsyncWithHttpInfo
     *
     * Update a folder
     *
     * @param int $folder_id (required)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdPutAsyncWithHttpInfo($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersFolderIdPutRequest($folder_id, $name, $position, $client_ids, $is_deletable, $is_selectable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdPut'
     *
     * @param int $folder_id (required)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param int $client_ids The IDs of the clients (stores). It is possible to determine which clients (stores) the newsletter folder is visible for. (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersFolderIdPutRequest($folder_id, $name = null, $position = null, $client_ids = null, $is_deletable = null, $is_selectable = null)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($position !== null) {
            $queryParams['position'] = ObjectSerializer::toQueryValue($position);
        }
        // query params
        if ($client_ids !== null) {
            $queryParams['clientIds'] = ObjectSerializer::toQueryValue($client_ids);
        }
        // query params
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = ObjectSerializer::toQueryValue($is_deletable);
        }
        // query params
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = ObjectSerializer::toQueryValue($is_selectable);
        }

        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGet
     *
     * List all recipients of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdRecipientsGet($folder_id)
    {
        list($response) = $this->restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersFolderIdRecipientsGetWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsync
     *
     * List all recipients of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsync($folder_id)
    {
        return $this->restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo
     *
     * List all recipients of a folder
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersFolderIdRecipientsGetAsyncWithHttpInfo($folder_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersFolderIdRecipientsGet'
     *
     * @param int $folder_id The ID of the newsletter folder. (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersFolderIdRecipientsGetRequest($folder_id)
    {
        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $folder_id when calling restNewslettersFoldersFolderIdRecipientsGet'
            );
        }

        $resourcePath = '/rest/newsletters/folders/{folderId}/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersGet
     *
     * List newsletter folders
     *
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersGet()
    {
        list($response) = $this->restNewslettersFoldersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersFoldersGetWithHttpInfo
     *
     * List newsletter folders
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersGetAsync
     *
     * List newsletter folders
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersGetAsync()
    {
        return $this->restNewslettersFoldersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersGetAsyncWithHttpInfo
     *
     * List newsletter folders
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersFoldersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersGet'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersGetRequest()
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersFoldersPost
     *
     * Create a folder
     *
     * @param object $body body (optional)
     * @param int $id The ID of the newsletter folder (optional)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsFolder
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersPost($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        list($response) = $this->restNewslettersFoldersPostWithHttpInfo($body, $id, $name, $position, $is_deletable, $is_selectable);
        return $response;
    }

    /**
     * Operation restNewslettersFoldersPostWithHttpInfo
     *
     * Create a folder
     *
     * @param object $body (optional)
     * @param int $id The ID of the newsletter folder (optional)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersFoldersPostWithHttpInfo($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersPostRequest($body, $id, $name, $position, $is_deletable, $is_selectable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersFoldersPostAsync
     *
     * Create a folder
     *
     * @param object $body (optional)
     * @param int $id The ID of the newsletter folder (optional)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersPostAsync($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        return $this->restNewslettersFoldersPostAsyncWithHttpInfo($body, $id, $name, $position, $is_deletable, $is_selectable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersFoldersPostAsyncWithHttpInfo
     *
     * Create a folder
     *
     * @param object $body (optional)
     * @param int $id The ID of the newsletter folder (optional)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersFoldersPostAsyncWithHttpInfo($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsFolder';
        $request = $this->restNewslettersFoldersPostRequest($body, $id, $name, $position, $is_deletable, $is_selectable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersFoldersPost'
     *
     * @param object $body (optional)
     * @param int $id The ID of the newsletter folder (optional)
     * @param string $name The name of the newsletter folder (optional)
     * @param int $position The position of the newsletter folder (optional)
     * @param bool $is_deletable Flag that indicates if the newsletter folder can be deleted. Default value of is deletable is 1. The folders &#x27;Customers&#x27; and &#x27;Interested parties&#x27; are available by default and cannot be deleted. (optional)
     * @param bool $is_selectable Flag that indicates if the newsletter folder can be selected by customers in the online store. If it is allowed, the folder will be displayed in the My account area of the online store. Customers will then be able to subscribe to the newsletters that are included in this folder. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersFoldersPostRequest($body = null, $id = null, $name = null, $position = null, $is_deletable = null, $is_selectable = null)
    {

        $resourcePath = '/rest/newsletters/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($position !== null) {
            $queryParams['position'] = ObjectSerializer::toQueryValue($position);
        }
        // query params
        if ($is_deletable !== null) {
            $queryParams['isDeletable'] = ObjectSerializer::toQueryValue($is_deletable);
        }
        // query params
        if ($is_selectable !== null) {
            $queryParams['isSelectable'] = ObjectSerializer::toQueryValue($is_selectable);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersGet
     *
     * List newsletter entries
     *
     *
     * @return PlentyModulesAccountNewsletterModelsEntry[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersGet()
    {
        list($response) = $this->restNewslettersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersGetWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersGetWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersGetAsync
     *
     * List newsletter entries
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersGetAsync()
    {
        return $this->restNewslettersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersGetAsyncWithHttpInfo
     *
     * List newsletter entries
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersGetAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry[]';
        $request = $this->restNewslettersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersGet'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersGetRequest()
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersListRecipientsGet
     *
     * List recipients
     *
     * @param int $columns Filter that restricts the search result to specific columns (optional)
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @return object
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersListRecipientsGet($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        list($response) = $this->restNewslettersListRecipientsGetWithHttpInfo($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);
        return $response;
    }

    /**
     * Operation restNewslettersListRecipientsGetWithHttpInfo
     *
     * List recipients
     *
     * @param int $columns Filter that restricts the search result to specific columns (optional)
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersListRecipientsGetWithHttpInfo($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restNewslettersListRecipientsGetRequest($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersListRecipientsGetAsync
     *
     * List recipients
     *
     * @param int $columns Filter that restricts the search result to specific columns (optional)
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersListRecipientsGetAsync($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        return $this->restNewslettersListRecipientsGetAsyncWithHttpInfo($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersListRecipientsGetAsyncWithHttpInfo
     *
     * List recipients
     *
     * @param int $columns Filter that restricts the search result to specific columns (optional)
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersListRecipientsGetAsyncWithHttpInfo($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {
        $returnType = 'object';
        $request = $this->restNewslettersListRecipientsGetRequest($columns, $page, $items_per_page, $folder_id, $is_confirmed, $with);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersListRecipientsGet'
     *
     * @param int $columns Filter that restricts the search result to specific columns (optional)
     * @param int $page The page to get. The default page that will be returned is page 1. (optional)
     * @param int $items_per_page The number of orders to be displayed per page. The default number of orders per page is 50. (optional)
     * @param int $folder_id Filter that restricts the search result to a specific folderId. (optional)
     * @param bool $is_confirmed Filter that restricts the search result to confirmed recipients. (optional)
     * @param int $with Load additional relations for a Recipient. CURRENTLY NOT AVAILABLE (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersListRecipientsGetRequest($columns = null, $page = null, $items_per_page = null, $folder_id = null, $is_confirmed = null, $with = null)
    {

        $resourcePath = '/rest/newsletters/list_recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($columns !== null) {
            $queryParams['columns'] = ObjectSerializer::toQueryValue($columns);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($is_confirmed !== null) {
            $queryParams['isConfirmed'] = ObjectSerializer::toQueryValue($is_confirmed);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersPost
     *
     * Create an entry
     *
     * @param object $body body (optional)
     * @param string $subject The subject of the newsletter entry (optional)
     * @param string $body2 The body of the newsletter entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsEntry
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersPost($body = null, $subject = null, $body2 = null, $kind = null)
    {
        list($response) = $this->restNewslettersPostWithHttpInfo($body, $subject, $body2, $kind);
        return $response;
    }

    /**
     * Operation restNewslettersPostWithHttpInfo
     *
     * Create an entry
     *
     * @param object $body (optional)
     * @param string $subject The subject of the newsletter entry (optional)
     * @param string $body2 The body of the newsletter entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersPostWithHttpInfo($body = null, $subject = null, $body2 = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersPostRequest($body, $subject, $body2, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersPostAsync
     *
     * Create an entry
     *
     * @param object $body (optional)
     * @param string $subject The subject of the newsletter entry (optional)
     * @param string $body2 The body of the newsletter entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersPostAsync($body = null, $subject = null, $body2 = null, $kind = null)
    {
        return $this->restNewslettersPostAsyncWithHttpInfo($body, $subject, $body2, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersPostAsyncWithHttpInfo
     *
     * Create an entry
     *
     * @param object $body (optional)
     * @param string $subject The subject of the newsletter entry (optional)
     * @param string $body2 The body of the newsletter entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersPostAsyncWithHttpInfo($body = null, $subject = null, $body2 = null, $kind = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsEntry';
        $request = $this->restNewslettersPostRequest($body, $subject, $body2, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersPost'
     *
     * @param object $body (optional)
     * @param string $subject The subject of the newsletter entry (optional)
     * @param string $body2 The body of the newsletter entry (optional)
     * @param string $kind The type of the entry. The content can be saved as plain text or in HTML format. Possible values: [&#x27;plain&#x27;, &#x27;html&#x27;]. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersPostRequest($body = null, $subject = null, $body2 = null, $kind = null)
    {

        $resourcePath = '/rest/newsletters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($subject !== null) {
            $queryParams['subject'] = ObjectSerializer::toQueryValue($subject);
        }
        // query params
        if ($body2 !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body2);
        }
        // query params
        if ($kind !== null) {
            $queryParams['kind'] = ObjectSerializer::toQueryValue($kind);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsDelete
     *
     * Delete recipients
     *
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsDelete()
    {
        list($response) = $this->restNewslettersRecipientsDeleteWithHttpInfo();
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsDeleteWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsDeleteWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsync
     *
     * Delete recipients
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsDeleteAsync()
    {
        return $this->restNewslettersRecipientsDeleteAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsDeleteAsyncWithHttpInfo
     *
     * Delete recipients
     *
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsDeleteAsyncWithHttpInfo()
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsDeleteRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsDelete'
     *
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsDeleteRequest()
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsGet
     *
     * List recipients of a folder
     *
     * @param string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient[]
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsGet($email = null, $folder_id = null, $recipient_id = null)
    {
        list($response) = $this->restNewslettersRecipientsGetWithHttpInfo($email, $folder_id, $recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsGetWithHttpInfo
     *
     * List recipients of a folder
     *
     * @param string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsGetWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsGetAsync
     *
     * List recipients of a folder
     *
     * @param string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsGetAsync($email = null, $folder_id = null, $recipient_id = null)
    {
        return $this->restNewslettersRecipientsGetAsyncWithHttpInfo($email, $folder_id, $recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsGetAsyncWithHttpInfo
     *
     * List recipients of a folder
     *
     * @param string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsGetAsyncWithHttpInfo($email = null, $folder_id = null, $recipient_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsGetRequest($email, $folder_id, $recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsGet'
     *
     * @param string $email Filter that restricts the search result to the email address of the recipient (optional)
     * @param int $folder_id Filter that restricts the search result to the folder ID (optional)
     * @param int $recipient_id Filter that restricts the search result to the recipient ID (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsGetRequest($email = null, $folder_id = null, $recipient_id = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($recipient_id !== null) {
            $queryParams['recipientId'] = ObjectSerializer::toQueryValue($recipient_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsPost
     *
     * Create a recipient
     *
     * @param object $body body (optional)
     * @param string $email The email address of the recipient (optional)
     * @param string $first_name The first name of the recipient (optional)
     * @param string $last_name The last name of the recipient (optional)
     * @param int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient[]
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsPost($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        list($response) = $this->restNewslettersRecipientsPostWithHttpInfo($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsPostWithHttpInfo
     *
     * Create a recipient
     *
     * @param object $body (optional)
     * @param string $email The email address of the recipient (optional)
     * @param string $first_name The first name of the recipient (optional)
     * @param string $last_name The last name of the recipient (optional)
     * @param int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[], HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsPostWithHttpInfo($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsPostAsync
     *
     * Create a recipient
     *
     * @param object $body (optional)
     * @param string $email The email address of the recipient (optional)
     * @param string $first_name The first name of the recipient (optional)
     * @param string $last_name The last name of the recipient (optional)
     * @param int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsPostAsync($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        return $this->restNewslettersRecipientsPostAsyncWithHttpInfo($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsPostAsyncWithHttpInfo
     *
     * Create a recipient
     *
     * @param object $body (optional)
     * @param string $email The email address of the recipient (optional)
     * @param string $first_name The first name of the recipient (optional)
     * @param string $last_name The last name of the recipient (optional)
     * @param int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsPostAsyncWithHttpInfo($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient[]';
        $request = $this->restNewslettersRecipientsPostRequest($body, $email, $first_name, $last_name, $folder_ids, $is_frontend, $ignore_visibility, $ip_address);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsPost'
     *
     * @param object $body (optional)
     * @param string $email The email address of the recipient (optional)
     * @param string $first_name The first name of the recipient (optional)
     * @param string $last_name The last name of the recipient (optional)
     * @param int $folder_ids The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param bool $is_frontend Value that indicates if the REST call was retrieved from the front end. Possible values are: &#x27;true&#x27; or &#x27;false&#x27;. True &#x3D; The REST call was retrieved from the front end. False &#x3D; The REST call was not retrieved from the front end. (optional)
     * @param bool $ignore_visibility Value that indicates if the REST call considers folders without visibility. Possible value: &#x27;true&#x27;. If the value &#x27;true&#x27; is set, the folder visibility will be ignored. This means that both visible and invisible folders will be listed depending on the folder IDs entered in the REST call. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsPostRequest($body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $is_frontend = null, $ignore_visibility = null, $ip_address = null)
    {

        $resourcePath = '/rest/newsletters/recipients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['firstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($last_name !== null) {
            $queryParams['lastName'] = ObjectSerializer::toQueryValue($last_name);
        }
        // query params
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = ObjectSerializer::toQueryValue($folder_ids);
        }
        // query params
        if ($is_frontend !== null) {
            $queryParams['isFrontend'] = ObjectSerializer::toQueryValue($is_frontend);
        }
        // query params
        if ($ignore_visibility !== null) {
            $queryParams['ignoreVisibility'] = ObjectSerializer::toQueryValue($ignore_visibility);
        }
        // query params
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = ObjectSerializer::toQueryValue($ip_address);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDelete
     *
     * Delete a recipient
     *
     * @param int $recipient_id recipient_id (required)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsRecipientIdDelete($recipient_id)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteWithHttpInfo
     *
     * Delete a recipient
     *
     * @param int $recipient_id (required)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsRecipientIdDeleteWithHttpInfo($recipient_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsync
     *
     * Delete a recipient
     *
     * @param int $recipient_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsync($recipient_id)
    {
        return $this->restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo
     *
     * Delete a recipient
     *
     * @param int $recipient_id (required)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdDeleteAsyncWithHttpInfo($recipient_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdDelete'
     *
     * @param int $recipient_id (required)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsRecipientIdDeleteRequest($recipient_id)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdDelete'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGet
     *
     * List a recipient
     *
     * @param int $recipient_id recipient_id (required)
     * @param int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsRecipientIdGet($recipient_id, $recipients_id = null)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id, $recipients_id);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetWithHttpInfo
     *
     * List a recipient
     *
     * @param int $recipient_id (required)
     * @param int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     * @throws InvalidArgumentException
     * @throws ApiException on non-2xx response
     */
    public function restNewslettersRecipientsRecipientIdGetWithHttpInfo($recipient_id, $recipients_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsync
     *
     * List a recipient
     *
     * @param int $recipient_id (required)
     * @param int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdGetAsync($recipient_id, $recipients_id = null)
    {
        return $this->restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id, $recipients_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo
     *
     * List a recipient
     *
     * @param int $recipient_id (required)
     * @param int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdGetAsyncWithHttpInfo($recipient_id, $recipients_id = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdGet'
     *
     * @param int $recipient_id (required)
     * @param int $recipients_id The ID of the newsletter folder. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsRecipientIdGetRequest($recipient_id, $recipients_id = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdGet'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($recipients_id !== null) {
            $queryParams['recipientsId'] = ObjectSerializer::toQueryValue($recipients_id);
        }

        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPut
     *
     * Update a recipient
     *
     * @param int $recipient_id recipient_id (required)
     * @param object $body body (optional)
     * @param string $email The email address of the newsletter recipient (optional)
     * @param string $first_name The first name of the newsletter recipient (optional)
     * @param string $last_name The last name of the newsletter recipient (optional)
     * @param int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param int $folder_id The ID of the newsletter folder. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @return PlentyModulesAccountNewsletterModelsRecipient
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdPut($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        list($response) = $this->restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);
        return $response;
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutWithHttpInfo
     *
     * Update a recipient
     *
     * @param int $recipient_id (required)
     * @param object $body (optional)
     * @param string $email The email address of the newsletter recipient (optional)
     * @param string $first_name The first name of the newsletter recipient (optional)
     * @param string $last_name The last name of the newsletter recipient (optional)
     * @param int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param int $folder_id The ID of the newsletter folder. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient, HTTP status code, HTTP response headers (array of strings)
     * @throws ApiException on non-2xx response
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdPutWithHttpInfo($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsync
     *
     * Update a recipient
     *
     * @param int $recipient_id (required)
     * @param object $body (optional)
     * @param string $email The email address of the newsletter recipient (optional)
     * @param string $first_name The first name of the newsletter recipient (optional)
     * @param string $last_name The last name of the newsletter recipient (optional)
     * @param int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param int $folder_id The ID of the newsletter folder. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdPutAsync($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        return $this->restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo
     *
     * Update a recipient
     *
     * @param int $recipient_id (required)
     * @param object $body (optional)
     * @param string $email The email address of the newsletter recipient (optional)
     * @param string $first_name The first name of the newsletter recipient (optional)
     * @param string $last_name The last name of the newsletter recipient (optional)
     * @param int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param int $folder_id The ID of the newsletter folder. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @return PromiseInterface
     * @throws InvalidArgumentException
     */
    public function restNewslettersRecipientsRecipientIdPutAsyncWithHttpInfo($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesAccountNewsletterModelsRecipient';
        $request = $this->restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body, $email, $first_name, $last_name, $folder_ids, $folder_id, $ip_address, $birthday, $gender);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restNewslettersRecipientsRecipientIdPut'
     *
     * @param int $recipient_id (required)
     * @param object $body (optional)
     * @param string $email The email address of the newsletter recipient (optional)
     * @param string $first_name The first name of the newsletter recipient (optional)
     * @param string $last_name The last name of the newsletter recipient (optional)
     * @param int $folder_ids DEPRECATED: The IDs of the newsletter folders. These folders were selected by the customer in the online store in order to receive newsletters included in these folders. (optional)
     * @param int $folder_id The ID of the newsletter folder. (optional)
     * @param string $ip_address The IP address from where the customer has confirmed the newsletter (optional)
     * @param string $birthday The customer birthday as Date string (e.g. &#x27;1982-11-24&#x27;, &#x27;1982/11/24&#x27; or &#x27;24.11.1982&#x27;) (optional)
     * @param string $gender The gender of the customer, one of the following values: &#x27;m&#x27;,&#x27;f&#x27;,&#x27;d&#x27;. (optional)
     *
     * @return Request
     * @throws InvalidArgumentException
     */
    protected function restNewslettersRecipientsRecipientIdPutRequest($recipient_id, $body = null, $email = null, $first_name = null, $last_name = null, $folder_ids = null, $folder_id = null, $ip_address = null, $birthday = null, $gender = null)
    {
        // verify the required parameter 'recipient_id' is set
        if ($recipient_id === null || (is_array($recipient_id) && count($recipient_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $recipient_id when calling restNewslettersRecipientsRecipientIdPut'
            );
        }

        $resourcePath = '/rest/newsletters/recipients/{recipientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($email !== null) {
            $queryParams['email'] = ObjectSerializer::toQueryValue($email);
        }
        // query params
        if ($first_name !== null) {
            $queryParams['firstName'] = ObjectSerializer::toQueryValue($first_name);
        }
        // query params
        if ($last_name !== null) {
            $queryParams['lastName'] = ObjectSerializer::toQueryValue($last_name);
        }
        // query params
        if ($folder_ids !== null) {
            $queryParams['folderIds'] = ObjectSerializer::toQueryValue($folder_ids);
        }
        // query params
        if ($folder_id !== null) {
            $queryParams['folderId'] = ObjectSerializer::toQueryValue($folder_id);
        }
        // query params
        if ($ip_address !== null) {
            $queryParams['ipAddress'] = ObjectSerializer::toQueryValue($ip_address);
        }
        // query params
        if ($birthday !== null) {
            $queryParams['birthday'] = ObjectSerializer::toQueryValue($birthday);
        }
        // query params
        if ($gender !== null) {
            $queryParams['gender'] = ObjectSerializer::toQueryValue($gender);
        }

        // path params
        if ($recipient_id !== null) {
            $resourcePath = str_replace(
                '{' . 'recipientId' . '}',
                ObjectSerializer::toPathValue($recipient_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @return array of http client options
     * @throws RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
