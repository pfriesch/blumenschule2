<?php
/**
 * DocumentApi
 * PHP version 5
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * plentymarkets REST-API
 *
 * The plentymarkets REST API expands the functionality of the plentymarkets CMS and allows access to resources, i.e. data records, via unique URI paths
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.8
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BSApp\Service\plentymarketsAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSApp\Service\plentymarketsAPI\ApiException;
use BSApp\Service\plentymarketsAPI\Configuration;
use BSApp\Service\plentymarketsAPI\HeaderSelector;
use BSApp\Service\plentymarketsAPI\ObjectSerializer;

/**
 * DocumentApi Class Doc Comment
 *
 * @category Class
 * @package  BSApp\Service\plentymarketsAPI
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DocumentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDelete
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id category_id (required)
     * @param  int $document_id document_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDelete($category_id, $document_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo($category_id, $document_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteWithHttpInfo($category_id, $document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsync($category_id, $document_id)
    {
        return $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($category_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Deletes a category document. The ID of the document must be specified.
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($category_id, $document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDocumentIdDelete'
     *
     * @param  int $category_id (required)
     * @param  int $document_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsDocumentIdDeleteRequest($category_id, $document_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restCategoriesCategoryIdDocumentsDocumentIdDelete'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGet
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGet($category_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo($category_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetWithHttpInfo($category_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsync
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsync($category_id)
    {
        return $this->restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo($category_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo
     *
     * Download category documents
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsDownloadsGetAsyncWithHttpInfo($category_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsDownloadsGet'
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsDownloadsGetRequest($category_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsDownloadsGet'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGet
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restCategoriesCategoryIdDocumentsGet($category_id)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsGetWithHttpInfo($category_id);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsGetWithHttpInfo($category_id)
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsync
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsync($category_id)
    {
        return $this->restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo($category_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo
     *
     * List documents of a category
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsGetAsyncWithHttpInfo($category_id)
    {
        $returnType = 'object';
        $request = $this->restCategoriesCategoryIdDocumentsGetRequest($category_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsGet'
     *
     * @param  int $category_id The ID of the category (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsGetRequest($category_id)
    {
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsGet'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPost
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  object $body body (optional)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]
     */
    public function restCategoriesCategoryIdDocumentsPost($documents, $category_id, $body = null, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null)
    {
        list($response) = $this->restCategoriesCategoryIdDocumentsPostWithHttpInfo($documents, $category_id, $body, $number, $number_with_prefix, $directory_id, $display_date);
        return $response;
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  object $body (optional)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restCategoriesCategoryIdDocumentsPostWithHttpInfo($documents, $category_id, $body = null, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]';
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $body, $number, $number_with_prefix, $directory_id, $display_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsync
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  object $body (optional)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsync($documents, $category_id, $body = null, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null)
    {
        return $this->restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo($documents, $category_id, $body, $number, $number_with_prefix, $directory_id, $display_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo
     *
     * Upload category documents
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  object $body (optional)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restCategoriesCategoryIdDocumentsPostAsyncWithHttpInfo($documents, $category_id, $body = null, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]';
        $request = $this->restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $body, $number, $number_with_prefix, $directory_id, $display_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restCategoriesCategoryIdDocumentsPost'
     *
     * @param  int $documents The array with the category documents (required)
     * @param  int $category_id The ID of the category (required)
     * @param  object $body (optional)
     * @param  int $number The document number (optional)
     * @param  string $number_with_prefix Number with prefix (optional)
     * @param  int $directory_id The directory ID (optional)
     * @param  string $display_date The date displayed on the document (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restCategoriesCategoryIdDocumentsPostRequest($documents, $category_id, $body = null, $number = null, $number_with_prefix = null, $directory_id = null, $display_date = null)
    {
        // verify the required parameter 'documents' is set
        if ($documents === null || (is_array($documents) && count($documents) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $documents when calling restCategoriesCategoryIdDocumentsPost'
            );
        }
        // verify the required parameter 'category_id' is set
        if ($category_id === null || (is_array($category_id) && count($category_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $category_id when calling restCategoriesCategoryIdDocumentsPost'
            );
        }

        $resourcePath = '/rest/categories/{categoryId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($documents !== null) {
            $queryParams['documents'] = ObjectSerializer::toQueryValue($documents);
        }
        // query params
        if ($number !== null) {
            $queryParams['number'] = ObjectSerializer::toQueryValue($number);
        }
        // query params
        if ($number_with_prefix !== null) {
            $queryParams['numberWithPrefix'] = ObjectSerializer::toQueryValue($number_with_prefix);
        }
        // query params
        if ($directory_id !== null) {
            $queryParams['directoryId'] = ObjectSerializer::toQueryValue($directory_id);
        }
        // query params
        if ($display_date !== null) {
            $queryParams['displayDate'] = ObjectSerializer::toQueryValue($display_date);
        }

        // path params
        if ($category_id !== null) {
            $resourcePath = str_replace(
                '{' . 'categoryId' . '}',
                ObjectSerializer::toPathValue($category_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restDocumentsDocumentIdGet
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restDocumentsDocumentIdGet($document_id)
    {
        list($response) = $this->restDocumentsDocumentIdGetWithHttpInfo($document_id);
        return $response;
    }

    /**
     * Operation restDocumentsDocumentIdGetWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restDocumentsDocumentIdGetWithHttpInfo($document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restDocumentsDocumentIdGetRequest($document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restDocumentsDocumentIdGetAsync
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsync($document_id)
    {
        return $this->restDocumentsDocumentIdGetAsyncWithHttpInfo($document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restDocumentsDocumentIdGetAsyncWithHttpInfo
     *
     * Download the content of a document
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restDocumentsDocumentIdGetAsyncWithHttpInfo($document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restDocumentsDocumentIdGetRequest($document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restDocumentsDocumentIdGet'
     *
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restDocumentsDocumentIdGetRequest($document_id)
    {
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restDocumentsDocumentIdGet'
            );
        }

        $resourcePath = '/rest/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGet
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse
     */
    public function restOrdersDocumentsDownloadsTypeGet($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        list($response) = $this->restOrdersDocumentsDownloadsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsDownloadsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsync
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsync($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        return $this->restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo
     *
     * Download documents of a document type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsDownloadsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsDownloadsTypeGet'
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The number of documents to display per page. The default number displayed is 50. The maximum number is 6000. (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsDownloadsTypeGetRequest($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsDownloadsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/documents/downloads/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contact_id !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = ObjectSerializer::toQueryValue($plenty_id);
        }
        // query params
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = ObjectSerializer::toQueryValue($created_at_from);
        }
        // query params
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = ObjectSerializer::toQueryValue($created_at_to);
        }
        // query params
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = ObjectSerializer::toQueryValue($display_date_from);
        }
        // query params
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = ObjectSerializer::toQueryValue($display_date_to);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersDocumentsTypeGet
     *
     * List documents of a type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersDocumentsTypeGet($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        list($response) = $this->restOrdersDocumentsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersDocumentsTypeGetWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersDocumentsTypeGetWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsync
     *
     * List documents of a type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsync($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        return $this->restOrdersDocumentsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersDocumentsTypeGetAsyncWithHttpInfo
     *
     * List documents of a type
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersDocumentsTypeGetAsyncWithHttpInfo($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id, $plenty_id, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersDocumentsTypeGet'
     *
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction, reversal, reversalRefund, proFormaInvoice. (required)
     * @param  int $page The page of results to search for (required)
     * @param  int $items_per_page The items per page to search for (required)
     * @param  int $contact_id Filter that restricts the search results to documents belonging to a specific contact ID. (optional)
     * @param  int $plenty_id Filter that restricts the search results to documents belonging to the specific plenty ID. (optional)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersDocumentsTypeGetRequest($type, $page, $items_per_page, $contact_id = null, $plenty_id = null, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersDocumentsTypeGet'
            );
        }
        // verify the required parameter 'page' is set
        if ($page === null || (is_array($page) && count($page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling restOrdersDocumentsTypeGet'
            );
        }
        // verify the required parameter 'items_per_page' is set
        if ($items_per_page === null || (is_array($items_per_page) && count($items_per_page) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $items_per_page when calling restOrdersDocumentsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($contact_id !== null) {
            $queryParams['contactId'] = ObjectSerializer::toQueryValue($contact_id);
        }
        // query params
        if ($plenty_id !== null) {
            $queryParams['plentyId'] = ObjectSerializer::toQueryValue($plenty_id);
        }
        // query params
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = ObjectSerializer::toQueryValue($created_at_from);
        }
        // query params
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = ObjectSerializer::toQueryValue($created_at_to);
        }
        // query params
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = ObjectSerializer::toQueryValue($display_date_from);
        }
        // query params
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = ObjectSerializer::toQueryValue($display_date_to);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($with_content !== null) {
            $queryParams['withContent'] = ObjectSerializer::toQueryValue($with_content);
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDelete
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse
     */
    public function restOrdersOrderIdDocumentsDocumentIdDelete($order_id, $document_id)
    {
        list($response) = $this->restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo($order_id, $document_id);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteWithHttpInfo($order_id, $document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsync
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsync($order_id, $document_id)
    {
        return $this->restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($order_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo
     *
     * Delete document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDocumentIdDeleteAsyncWithHttpInfo($order_id, $document_id)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyRepositoriesModelsDeleteResponse';
        $request = $this->restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDocumentIdDelete'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  int $document_id The ID of the document (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsDocumentIdDeleteRequest($order_id, $document_id)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling restOrdersOrderIdDocumentsDocumentIdDelete'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDownloadsTypeGet
     *
     * Download documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the document. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoreExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation and correction. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse
     */
    public function restOrdersOrderIdDocumentsDownloadsTypeGet($order_id, $type)
    {
        list($response) = $this->restOrdersOrderIdDocumentsDownloadsTypeGetWithHttpInfo($order_id, $type);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsDownloadsTypeGetWithHttpInfo
     *
     * Download documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the document. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoreExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation and correction. (required)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsDownloadsTypeGetWithHttpInfo($order_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restOrdersOrderIdDocumentsDownloadsTypeGetRequest($order_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsDownloadsTypeGetAsync
     *
     * Download documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the document. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoreExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation and correction. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDownloadsTypeGetAsync($order_id, $type)
    {
        return $this->restOrdersOrderIdDocumentsDownloadsTypeGetAsyncWithHttpInfo($order_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsDownloadsTypeGetAsyncWithHttpInfo
     *
     * Download documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the document. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoreExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation and correction. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsDownloadsTypeGetAsyncWithHttpInfo($order_id, $type)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\SymfonyComponentHttpFoundationStreamedResponse';
        $request = $this->restOrdersOrderIdDocumentsDownloadsTypeGetRequest($order_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsDownloadsTypeGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the document. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoreExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation and correction. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsDownloadsTypeGetRequest($order_id, $type)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsDownloadsTypeGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsDownloadsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/downloads/{type?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePost
     *
     * Generate document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;reorder&#x27;, &#x27;poDeliveryNote&#x27;. (required)
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePost($order_id, $type, $body = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo($order_id, $type, $body);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;reorder&#x27;, &#x27;poDeliveryNote&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostWithHttpInfo($order_id, $type, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsync
     *
     * Generate document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;reorder&#x27;, &#x27;poDeliveryNote&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsync($order_id, $type, $body = null)
    {
        return $this->restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo($order_id, $type, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo
     *
     * Generate document of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;reorder&#x27;, &#x27;poDeliveryNote&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGeneratePostAsyncWithHttpInfo($order_id, $type, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyDataSimpleRestResponse';
        $request = $this->restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeGeneratePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;reorder&#x27;, &#x27;poDeliveryNote&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypeGeneratePostRequest($order_id, $type, $body = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeGeneratePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGet
     *
     * List documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function restOrdersOrderIdDocumentsTypeGet($order_id, $type, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypeGetWithHttpInfo($order_id, $type, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGetWithHttpInfo
     *
     * List documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypeGetWithHttpInfo($order_id, $type, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsTypeGetRequest($order_id, $type, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGetAsync
     *
     * List documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGetAsync($order_id, $type, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        return $this->restOrdersOrderIdDocumentsTypeGetAsyncWithHttpInfo($order_id, $type, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypeGetAsyncWithHttpInfo
     *
     * List documents of an order
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypeGetAsyncWithHttpInfo($order_id, $type, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        $returnType = 'object';
        $request = $this->restOrdersOrderIdDocumentsTypeGetRequest($order_id, $type, $created_at_from, $created_at_to, $display_date_from, $display_date_to, $with, $with_content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypeGet'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The type of the order documents. The types available are receipt, invoiceExternal, invoice, deliveryNote, poDeliveryNote, creditNote, creditNoteExternal, orderConfirmation, offer, dunningLetter, returnNote, successConfirmation, correction. (required)
     * @param  string $created_at_from Filter that restricts the search result to documents that were created on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $created_at_to Filter that restricts the search result to documents that were created within a certain period of time. This filter can be used alone or can be combined with the CreatedAtFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_from Filter that restricts the search result to documents that were displayed on the specified date. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  string $display_date_to Filter that restricts the search result to documents that were displayed within a certain period of time. This filter can be used alone or can be combined with the displayDateFrom filter. The date has to be in the W3C format, e.g. &#x27;2016-10-24T13:33:23+02:00&#x27;. (optional)
     * @param  int $with Load additional relations for a document. Currently possible are:     &lt;ul&gt;     &lt;li&gt;&#x27;references&#x27; &#x3D; The document reference objects that are associated with the document.&lt;/li&gt;     &lt;/ul&gt;     Example: &lt;code&gt;?with[]&#x3D;references&lt;/code&gt; (optional)
     * @param  bool $with_content Load also the document content as base64 encoded string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypeGetRequest($order_id, $type, $created_at_from = null, $created_at_to = null, $display_date_from = null, $display_date_to = null, $with = null, $with_content = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypeGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypeGet'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type?}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($created_at_from !== null) {
            $queryParams['createdAtFrom'] = ObjectSerializer::toQueryValue($created_at_from);
        }
        // query params
        if ($created_at_to !== null) {
            $queryParams['createdAtTo'] = ObjectSerializer::toQueryValue($created_at_to);
        }
        // query params
        if ($display_date_from !== null) {
            $queryParams['displayDateFrom'] = ObjectSerializer::toQueryValue($display_date_from);
        }
        // query params
        if ($display_date_to !== null) {
            $queryParams['displayDateTo'] = ObjectSerializer::toQueryValue($display_date_to);
        }
        // query params
        if ($with !== null) {
            $queryParams['with'] = ObjectSerializer::toQueryValue($with);
        }
        // query params
        if ($with_content !== null) {
            $queryParams['withContent'] = ObjectSerializer::toQueryValue($with_content);
        }

        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePost
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;invoiceExternal&#x27;, &#x27;deliveryNote&#x27;, &#x27;poDeliveryNote&#x27;, &#x27;orderConfirmation&#x27;, &#x27;offer&#x27;, &#x27;dunningLetter&#x27;, &#x27;returnNote&#x27;, &#x27;successConfirmation&#x27;, &#x27;correction&#x27;, &#x27;creditNoteExternal&#x27;, &#x27;reorder&#x27;. (required)
     * @param  object $body body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]
     */
    public function restOrdersOrderIdDocumentsTypePost($order_id, $type, $body = null)
    {
        list($response) = $this->restOrdersOrderIdDocumentsTypePostWithHttpInfo($order_id, $type, $body);
        return $response;
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;invoiceExternal&#x27;, &#x27;deliveryNote&#x27;, &#x27;poDeliveryNote&#x27;, &#x27;orderConfirmation&#x27;, &#x27;offer&#x27;, &#x27;dunningLetter&#x27;, &#x27;returnNote&#x27;, &#x27;successConfirmation&#x27;, &#x27;correction&#x27;, &#x27;creditNoteExternal&#x27;, &#x27;reorder&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \BSApp\Service\plentymarketsAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[], HTTP status code, HTTP response headers (array of strings)
     */
    public function restOrdersOrderIdDocumentsTypePostWithHttpInfo($order_id, $type, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]';
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsync
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;invoiceExternal&#x27;, &#x27;deliveryNote&#x27;, &#x27;poDeliveryNote&#x27;, &#x27;orderConfirmation&#x27;, &#x27;offer&#x27;, &#x27;dunningLetter&#x27;, &#x27;returnNote&#x27;, &#x27;successConfirmation&#x27;, &#x27;correction&#x27;, &#x27;creditNoteExternal&#x27;, &#x27;reorder&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsync($order_id, $type, $body = null)
    {
        return $this->restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo($order_id, $type, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo
     *
     * Upload order documents
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;invoiceExternal&#x27;, &#x27;deliveryNote&#x27;, &#x27;poDeliveryNote&#x27;, &#x27;orderConfirmation&#x27;, &#x27;offer&#x27;, &#x27;dunningLetter&#x27;, &#x27;returnNote&#x27;, &#x27;successConfirmation&#x27;, &#x27;correction&#x27;, &#x27;creditNoteExternal&#x27;, &#x27;reorder&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restOrdersOrderIdDocumentsTypePostAsyncWithHttpInfo($order_id, $type, $body = null)
    {
        $returnType = '\BSApp\Service\plentymarketsAPI\Model\PlentyModulesDocumentModelsDocument[]';
        $request = $this->restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restOrdersOrderIdDocumentsTypePost'
     *
     * @param  int $order_id The ID of the order (required)
     * @param  string $type The document type. Supported types are &#x27;invoiceExternal&#x27;, &#x27;deliveryNote&#x27;, &#x27;poDeliveryNote&#x27;, &#x27;orderConfirmation&#x27;, &#x27;offer&#x27;, &#x27;dunningLetter&#x27;, &#x27;returnNote&#x27;, &#x27;successConfirmation&#x27;, &#x27;correction&#x27;, &#x27;creditNoteExternal&#x27;, &#x27;reorder&#x27;. (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restOrdersOrderIdDocumentsTypePostRequest($order_id, $type, $body = null)
    {
        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling restOrdersOrderIdDocumentsTypePost'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling restOrdersOrderIdDocumentsTypePost'
            );
        }

        $resourcePath = '/rest/orders/{orderId}/documents/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
